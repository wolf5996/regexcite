---
title: "Package Development"
author: "Badran Elshenawy"
date: 2025-04-25T12:00:00Z
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 2
    self-contained: true
    title-block-banner: true
---

# Context

-   Working with TCGA data, I came to the realization that TCGA lacks good visualisation packages. I can create my own package, and that would be a solid publication on its own.

-   What I will do now is go through [R packages (2e)](https://r-pkgs.org/) to learn the basics of package development in general and for R specifically.

-   I will then use my own skills in combination with ChatGPT/LLMs to create a full package with documentation.

-   This is a side project that I anticipate will take several months to complete—it will teach me an immense amount about software development and has the potential to boost my CV with a full package of my own.

-   For my note-taking style, I will try to be more chill and focus on the actual book.

    -   Do not intend to include a massive amount of notes and use this document as a comprehensive reference.

    -   This is just a few points I will jot down as I go through the book. I think I value consuming the information and understanding it more than I do note-taking at this current stage of my development.

-   During my work on this book, I thought about switching a bit towards Quarto or positron for this guide.

    -   However, I think that's a poor idea because this book clearly states that it is designed to work with RStudio, which has a host of functions and utilities built-in that are meant to make the process of package development smooth.

-   The final evolution of this is going to be a ChatGPT or Claude project where each thread handles an aspect of the package, and I will be using that to create my own ggTCGA package.

    -   I can then use this package internally for my own analysis of TCGA data and publish the package as a paper on biorevix.

        -   This is a solid plan and one that I think holds immense value for me.

            -   If you are wondering why other people would not do the same thing, well it's because they do not have the foresight needed to learn fundamentals and the vision necessary to execute on these using LLMs to handle details and using their brains to handle higher level management of LLM performance and abstraction.

# Notes

-   Throughout this book:

    -   `fun()` refers to functions.

    -   `var` refers to variables and function arguments.

    -   `path/` for paths.

-   **2025-04-25:** Finished welcome and preface. Will start at introduction next time. Should check for a pirated PDF version.

-   **2025-04-28:** Read the **`Introduction`**. Will start at **`The Whole Game`** next time.

# Chapter 1: The Whole Game

-   **Note:** setting WD is not necessary here at all, and the reason is that R projects set the working directory automatically.

-   Will walk through the development of a toy package called `regexcite`.

-   Should embody all the steps of package developments, which future chapters will delve into in more detail.

```{r}
# setwd
# setwd(
#   dirname(
#     rstudioapi::getActiveDocumentContext()$path
#   )
# )
# libraries
library(devtools)
packageVersion("devtools")

# creating the package
# create_package(
#   path = "regexcite"
# )
```

-   This code creates a directory which will contain my package and opens a new R session relating to the package R project.

-   The relevant files created by this are:

    -   `.Rbuildignore` lists files that we need to have around but that should not be included when building the R package from source. If you aren’t using RStudio, [`create_package()`](https://usethis.r-lib.org/reference/create_package.html) may not create this file (nor `.gitignore`) at first, since there’s no RStudio-related machinery that needs to be ignored. However, you will likely develop the need for `.Rbuildignore` at some point, regardless of what editor you are using. It is discussed in more detail in [Section 3.3.1](https://r-pkgs.org/structure.html#sec-rbuildignore).

    -   `.Rproj.user`, if you have it, is a directory used internally by RStudio.

    -   `.gitignore` anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.

    -   `DESCRIPTION` provides metadata about your package. We edit this shortly and [Chapter 9](https://r-pkgs.org/description.html) covers the general topic of the `DESCRIPTION` file.

    -   `NAMESPACE` declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.

    -   The `R/` directory is the “business end” of your package. It will soon contain `.R` files with function definitions.

    -   `regexcite.Rproj` is the file that makes this directory an RStudio Project. Even if you don’t use RStudio, this file is harmless. Or you can suppress its creation with `create_package(..., rstudio = FALSE)`. More in [Section 4.2](https://r-pkgs.org/workflow101.html#sec-workflow101-rstudio-projects).

-   **2025-04-30:** finished sections 1.1-1.4. Will start on section 1.5 (`use_git()`) tomorrow.

    -   So far, the process seems very nice and straightforward.

-   The regexcite directory is an **`R source package`** and **`an RStudio Project`**. The next command will also turn it into a `git` repository.

-   `use_r()`: opens an R script inside `R/` where I can put my function definition. The name of the R script is the argument input to `use_r` and should be the same as the name of the function.

-   `load_all()`: loads all of the functions defined in the package without actually adding them to the global env. Good way of testing the package as it matures.

```{r git_function_creation_loading}
# using git in the repo project/directory
use_git()

# coding the first function
strsplit1 <- function(x, split){
  strsplit(x, split = split)[[1]]
}

# use_r()
use_r("strsplit1")

# load_all()
load_all()

# example test
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")

# checking for existence in global env
exists(
  "strsplit1",
  where = globalenv(),
  inherits = FALSE
)

```

-   **2025-05-01:** stopped at section 1.9 `check()`.
-   `check()`: checks that your package is still in working order.
-   `CTRL` + `.`: excellent keyboard shortcut to go to any other file in your project and open it in Rstudio.
-   Editing Description is easy and allows you to add metadata information about myself as the author and the package.
-   `use_mit_license()`: adds the license.
-   `document()`: creates the documentation for package functions.
    -   Documentation for a single function is handled using `roxygen2`. Check the source code file for `strsplit1()` to see the skeleton I had to insert and edit.
    -   This then creates a helper `strsplit1.Rd` file inside the `man` directory.
-   The export directive in `NAMESPACE` is what makes `strsplit1()` available to a user after attaching regexcite via [`library(regexcite)`](https://rdrr.io/r/base/library.html). Just as it is entirely possible to author `.Rd` files “by hand”, you can manage `NAMESPACE` explicitly yourself. But we choose to delegate this to devtools (and roxygen2).
    -   This happened because the roxygen2 skeleton we inserted into the source code had the @export tag.

```{r mit_license_and_document}
# check()
check()

# use_mit_license()
use_mit_license()

# document()
document()

# second check()
check()
```

-   **2025-05-06:** Stopped at section 1.14 `install()`
-   `install()`: installs the package I just created.

```{r install}
# install()
install()

# laoding regexcite
library(regexcite)

# testing
x <- "alfa,bravo,charlie,delta"
regexcite::strsplit1(x, split = ",")

```

-   Testing seems to be the most complex topic of all with many tools coming into play.

-   `use_testthat()`: initializes the structure for testing.

-   `use_test()`: creates the test with the name we want. Ideally, that should match the name of the function.

-   The actual test itself is a simple check of whether the function generates the expected output using a simplistic example. This is done using `expect_equal()` function.

```{r use_testthat}
# initializing
use_testthat()

# creating actual test
use_test("strsplit1")

# test
test()
```

-   `use_package()`: specifies the package that we will be using functions from.

-   We then batch rename the R code file for our function and the associated test file using `rename_files()`. We then go into these files and change the source code and the affiliated tests.

-   We then call `document()` again to update the documentation and the NAMESPACE. The latter is vital to make sure that our new function names are available.

-   We then call `load_all()` to test drive the new function.

```{r use_package}
# use
use_package("stringr")

# renaming
rename_files("strsplit1", "str_split_one")

# documenting
document()

# loading again
load_all()

# testing
str_split_one(string = "a,b,c", pattern = ",") # works
str_split_one(string = c("a,b,c","d"), pattern = ",") # does not work
```

-   **2025-05-08:** Stopped at `use_github()`
-   Multiple approaches to connect my repo with GitHub. I am going to try `use_github()` here.
-   I used it and it did magic for me. It created the full GitHub repo, added its URL as my origin, and synced everything between my local analysis thusfar and the newly created GitHub repo.
    -   Phenomenal shit, and this is exactly what I intend to use for my own analysis repos as well to faciliate the creation of GitHub repos.
        -   There is a reason I was very keen to go through this book even on my day off.
-   `use_readme_rmd()`: creates an Rmd file that is then used to build my md file for the repo. Excellent for having live code and showing people general usage and installation of the package.
-   Final `check()` and `install()` to make sure everything is in order before moving on.

```{r}
# use_github()
use_github()

# use_readme_rmd()
use_readme_rmd()

# build_readme()
build_readme()

# final check
check()

# final install
install()
```

-   This is the general overview of the process.

    -   `load_all()`: makes all of the functions available so they can be tested and improved.

    -   `testthat` and `test()`: allow you to create tests and run them to ensure your packages are tested and working fine.

    -   `roxygen2`: handles documentation.

    -   Then, you commit and push to GitHub, where GitHub actions are taken.

        -   The very last step is the only mysterious bit to me.

![](images/clipboard-4036790326.png)

## Chapter Summary

-   **Note:** This summary is from the book directly, and I think it's a very good overview of everything that this chapter covered as well as the full workflow of package development.

    -   Now that I am thinking about it, the only thing I think I will struggle with is writing tests for visualisations.

    -   I do not know how people create these but I think the book will go into these aspects in more detail in later chapters.

Here is a review of the key functions you’ve seen in this chapter, organized roughly by their role in the development process.

These functions setup parts of the package and are typically called once per package:

-   [`create_package()`](https://usethis.r-lib.org/reference/create_package.html)

-   [`use_git()`](https://usethis.r-lib.org/reference/use_git.html)

-   [`use_mit_license()`](https://usethis.r-lib.org/reference/licenses.html)

-   [`use_testthat()`](https://usethis.r-lib.org/reference/use_testthat.html)

-   [`use_github()`](https://usethis.r-lib.org/reference/use_github.html)

-   [`use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html)

You will call these functions on a regular basis, as you add functions and tests or take on dependencies:

-   [`use_r()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_test()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_package()`](https://usethis.r-lib.org/reference/use_package.html)

You will call these functions multiple times per day or per hour, during development:

-   [`load_all()`](https://devtools.r-lib.org/reference/load_all.html)

-   [`document()`](https://devtools.r-lib.org/reference/document.html)

-   [`test()`](https://devtools.r-lib.org/reference/test.html)

-   [`check()`](https://devtools.r-lib.org/reference/check.html)

# Chapter 2: System Setup

-   **2025-05-10:** This is where I stopped after the end of chapter 1. Next time is the start of chapter 2
-   **Notes:** I have switched to a style of note-taking that relies on Claude to summarize the key points of the section into a few pivotal bullet points
    -   I think this is a very good way of doing it, and it is especially nice given Claude's flexibility when it comes to the formatting of the inputs
    -   Using ```` ``` ```` allows me to input markdown, which is excellent for formatting my inputs
-   **Using devtools and Its Constituent Packages**
    -   Load devtools with `library(devtools)`
    -   Access all functions directly without qualification (e.g., `load_all()`) when developing packages interactively
    -   This approach is recommended when developing packages interactively
-   **Within Package Code** - Do NOT depend on devtools in your package code - Access functions from their primary home packages (e.g., use `sessioninfo::session_info()` instead of `devtools::session_info()`)
    -   This refers to the use-case where the package being developed uses one of the functions that `devtools` makes available, in which case it is far better to reference the home package rather than `devtools` directly.
-   **Bug Reporting** - Report issues to the package that is a function's primary home - Check the help for `devtools::fcn()` to determine a function's origin
-   **Using usethis** - usethis is a notable constituent package that many developers use directly - usethis is automatically attached when you load devtools with `library(devtools)` - You can use usethis functions without qualification after loading devtools - For programmatic style, use explicit namespace: `usethis::use_testthat()`

```{r}
# preparing my system
pak::pak(
 c("devtools",
  "roxygen2",
  "testthat",
  "knitr")
)

# laoding devtools
library(devtools)

# ensuring devtools is always loaded
use_devtools()
```

-   **Personal startup configuration for devtools**

    -   Add devtools to `.Rprofile` for automatic loading in every R session

    -   Use `if (interactive()) { suppressMessages(require(devtools)) }` in `.Rprofile`

    -   The `use_devtools()` function helps set this up automatically

-   **Caution with `.Rprofile`** - Normally avoid adding packages to `.Rprofile` as it creates hidden dependencies - devtools is an exception as it's a workflow package, not for analysis scripts - Only load in interactive sessions to maintain good practices

-   **Setting your defaults in usethis** - Configure personal information in `.Rprofile` with the `options()` function - Set default author information with `"Authors@R"` containing name, email, and roles - Define preferred license with `License` option

-   **Getting development versions** - Install latest unreleased features with `devtools::install_github("r-lib/devtools")` - Alternative method using pak: `pak::pak("r-lib/devtools")`

-   **2025-05-12:** Stopped at ***2.3. R Build Toolchain***

-   **Build Toolchain Requirements:**

    -   This is only necessary for packages that use C or C++, and that's not likely anything I will be using in my development early on

    -   **Windows:** Install Rtools from CRAN (do not edit PATH; save version info to registry)

    -   **macOS:** Install Xcode command line tools (`xcode-select --install`)

    -   **Linux:** Install R development packages (e.g., `r-base-dev` on Ubuntu)

-   **Verification:**

    -   Run `devtools::dev_sitrep()` to check your development environment

    -   Update any outdated packages or dependencies as suggested

-   **Environment Checks:**

    -   `dev_sitrep()`: reports package development situation, including:

        -   R version
        -   RStudio version
        -   devtools status
        -   package dependencies

    -   This is very useful even outside of package development

```{r}
devtools::dev_sitrep()
```

# Chapter 3: Package Structure & State

-   **2025-02-13:** Finished chapter 2. Next time is the start of chapter 3

-   This is the end of a very long day today with 3 meetings, one of which was 4 hours

-   However, the satisfaction of moving forward is better than any release I get from walking away

-   **Five package states**:

    -   **Source (development form)**

    -   **Bundled**

    -   **Binary**

    -   **Installed**

    -   **In-Memory**

-   **Key transitions**:

    -   Source → Installed (`devtools::install()` or `install.packages()`)
    -   Installed → In-Memory (`library()`)

-   **2025-05-15:** Stopped at the start of bundled packages

    -   Source and package states made a lot of sense and wanted to be paying more attention when I did this

-   **Bundled packages** are compressed into `.tar.gz` files (source tarballs), serving as an intermediary between source and installed packages

-   Create bundled packages from local development using `devtools::build()`

-   **Key differences between source and bundled packages**:

    -   Vignettes are pre-built with rendered outputs in inst/doc/
    -   Temporary development files are removed
    -   Files listed in `.Rbuildignore` are excluded

-   The `.Rbuildignore` file is crucial for controlling which files from source are included in downstream forms, including **bundled**

-   Always use `usethis::use_build_ignore()` to manage `.Rbuildignore` entries because:

    -   It handles required regex anchoring automatically
    -   Regular expressions must be anchored (e.g., `^notes$` not just `notes`)
    -   Improper anchoring can unintentionally exclude important files

-   Many `usethis` functions automatically add relevant files to `.Rbuildignore` when creating them (e.g., `use_readme_rmd()`)

-   Common files to exclude via `.Rbuildignore`:

    -   Files that generate package contents (README.Rmd, data creation scripts)
    -   Development tools (RStudio project files, CI/CD configs)
    -   Documentation outside CRAN's requirements (pkgdown files)

-   Common entries in the `.Rbuildignore` file that exemplify the above file types are included below

| Pattern               | Purpose                                          |
|-----------------------|--------------------------------------------------|
| `^.*\.Rproj$`         | Designates the directory as an RStudio Project   |
| `^\.Rproj\.user$`     | Used by RStudio for temporary files              |
| `^README\.Rmd$`       | An Rmd file used to generate README.md           |
| `^LICENSE\.md$`       | Full text of the license                         |
| `^cran-comments\.md$` | Comments for CRAN submission                     |
| `^data-raw$`          | Code used to create data included in the package |
| `^pkgdown$`           | Resources used for the package website           |
| `^_pkgdown\.yml$`     | Configuration info for the package website       |
| `^\.github$`          | GitHub Actions workflows                         |

-   Following proper bundling conventions ensures compatibility with R's built-in tooling for package checking and installation

```{r}
# rbuildignore
usethis::use_build_ignore("notes.qmd")
```

-   **2025-05-16**: stopped at section 3.4 Binary Packages and very happy with this book so far
    -   I have also started to aggressively implement the new convention of ignoring full stops in my sentences
        -   If I need another sentence, I just nest it as a bullet point that flows from the preceding one

**R Binary Packages Summary**

-   **Purpose**: Binary packages (`.tgz` for macOS, `.zip` for Windows) allow distribution to users without development tools

-   **Distribution**: CRAN is the primary creator/distributor of binaries, not individual maintainers

-   **Creation**: Developers can create binaries with `devtools::build(binary = TRUE)` on the relevant OS

-   **Structure differences**: Binary packages have a transformed internal structure:

    -   R code is stored in parsed, efficient format (not as .R files)
    -   Contains `Meta/` directory with cached metadata
    -   Help content reorganized into `help`/ and `html/` folders
    -   Compiled code moved to `libs/` directory
    -   `inst/` contents moved to top-level
        -   Several development files/folders are removed

**R Installed Packages Summary**

-   **Definition**: An installed package is a binary package that's been decompressed into a package library

-   **Installation methods**: Multiple pathways exist to install packages:

    -   `R CMD INSTALL` is the underlying tool for all package installation
    -   `install.packages()` allows installation from within R sessions
    -   RStudio provides GUI options in the Build pane
    -   devtools/remotes offers specialized `install_*()` functions for various sources

-   **Challenges**: Re-installing packages already in use can be problematic:

    -   Windows users face "locked DLL" issues with compiled code
    -   Clean R sessions with minimal loaded packages recommended for troubleshooting

-   **Emerging solutions**: The `pak` package provides alternatives that:

    -   Solves the Windows "locked DLL" problem
    -   Offers advanced dependency management capabilities
    -   Is increasingly recommended for package installation tasks

![](images/clipboard-3399855533.png)

```{r}
usethis::use_git_ignore(ignores = "images/")
```

-   **2025-05-18:** Stopped at section 3.6 In-memory package

    -   Making good progress here and should more time on this to wrap it up quicker

    -   The information here is opening up a lot of discussion points and pathways I was not aware of

    -   Moving forward with these quick claude summaries and efficient reading is a very good combination
