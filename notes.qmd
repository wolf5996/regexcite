---
title: "Package Development"
author: "Badran Elshenawy"
date: 2025-04-25T12:00:00Z
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 2
    self-contained: true
    title-block-banner: true
---

# Context

-   Working with TCGA data, I came to the realization that TCGA lacks good visualisation packages. I can create my own package, and that would be a solid publication on its own.

-   What I will do now is go through [R packages (2e)](https://r-pkgs.org/) to learn the basics of package development in general and for R specifically.

-   I will then use my own skills in combination with ChatGPT/LLMs to create a full package with documentation.

-   This is a side project that I anticipate will take several months to complete—it will teach me an immense amount about software development and has the potential to boost my CV with a full package of my own.

-   For my note-taking style, I will try to be more chill and focus on the actual book.

    -   Do not intend to include a massive amount of notes and use this document as a comprehensive reference.

    -   This is just a few points I will jot down as I go through the book. I think I value consuming the information and understanding it more than I do note-taking at this current stage of my development.

-   During my work on this book, I thought about switching a bit towards Quarto or positron for this guide.

    -   However, I think that's a poor idea because this book clearly states that it is designed to work with RStudio, which has a host of functions and utilities built-in that are meant to make the process of package development smooth.

-   The final evolution of this is going to be a ChatGPT or Claude project where each thread handles an aspect of the package, and I will be using that to create my own ggTCGA package.

    -   I can then use this package internally for my own analysis of TCGA data and publish the package as a paper on biorevix.

        -   This is a solid plan and one that I think holds immense value for me.

            -   If you are wondering why other people would not do the same thing, well it's because they do not have the foresight needed to learn fundamentals and the vision necessary to execute on these using LLMs to handle details and using their brains to handle higher level management of LLM performance and abstraction.

-   Another important side project I can do is a small package containing helper functions I use

    -   These are going to be the same visualisation functions I use but with my preferred presets

    -   The idea here is to create a very simple package that I can use myself, thereby familiarizing myself with the developer and user sides of the package

# Notes

-   Throughout this book:

    -   `fun()` refers to functions.

    -   `var` refers to variables and function arguments.

    -   `path/` for paths.

-   **2025-04-25:** Finished welcome and preface. Will start at introduction next time. Should check for a pirated PDF version.

-   **2025-04-28:** Read the **`Introduction`**. Will start at **`The Whole Game`** next time.

# Chapter 1: The Whole Game

-   **Note:** setting WD is not necessary here at all, and the reason is that R projects set the working directory automatically.

-   Will walk through the development of a toy package called `regexcite`.

-   Should embody all the steps of package developments, which future chapters will delve into in more detail.

```{r}
# setwd
# setwd(
#   dirname(
#     rstudioapi::getActiveDocumentContext()$path
#   )
# )
# libraries
library(devtools)
packageVersion("devtools")

# creating the package
# create_package(
#   path = "regexcite"
# )
```

-   This code creates a directory which will contain my package and opens a new R session relating to the package R project.

-   The relevant files created by this are:

    -   `.Rbuildignore` lists files that we need to have around but that should not be included when building the R package from source. If you aren’t using RStudio, [`create_package()`](https://usethis.r-lib.org/reference/create_package.html) may not create this file (nor `.gitignore`) at first, since there’s no RStudio-related machinery that needs to be ignored. However, you will likely develop the need for `.Rbuildignore` at some point, regardless of what editor you are using. It is discussed in more detail in [Section 3.3.1](https://r-pkgs.org/structure.html#sec-rbuildignore).

    -   `.Rproj.user`, if you have it, is a directory used internally by RStudio.

    -   `.gitignore` anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.

    -   `DESCRIPTION` provides metadata about your package. We edit this shortly and [Chapter 9](https://r-pkgs.org/description.html) covers the general topic of the `DESCRIPTION` file.

    -   `NAMESPACE` declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.

    -   The `R/` directory is the “business end” of your package. It will soon contain `.R` files with function definitions.

    -   `regexcite.Rproj` is the file that makes this directory an RStudio Project. Even if you don’t use RStudio, this file is harmless. Or you can suppress its creation with `create_package(..., rstudio = FALSE)`. More in [Section 4.2](https://r-pkgs.org/workflow101.html#sec-workflow101-rstudio-projects).

-   **2025-04-30:** finished sections 1.1-1.4. Will start on section 1.5 (`use_git()`) tomorrow.

    -   So far, the process seems very nice and straightforward.

-   The regexcite directory is an **`R source package`** and **`an RStudio Project`**. The next command will also turn it into a `git` repository.

-   `use_r()`: opens an R script inside `R/` where I can put my function definition. The name of the R script is the argument input to `use_r` and should be the same as the name of the function.

-   `load_all()`: loads all of the functions defined in the package without actually adding them to the global env. Good way of testing the package as it matures.

```{r git_function_creation_loading}
# using git in the repo project/directory
use_git()

# coding the first function
strsplit1 <- function(x, split){
  strsplit(x, split = split)[[1]]
}

# use_r()
use_r("strsplit1")

# load_all()
load_all()

# example test
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")

# checking for existence in global env
exists(
  "strsplit1",
  where = globalenv(),
  inherits = FALSE
)

```

-   **2025-05-01:** stopped at section 1.9 `check()`.
-   `check()`: checks that your package is still in working order.
-   `CTRL` + `.`: excellent keyboard shortcut to go to any other file in your project and open it in Rstudio.
-   Editing Description is easy and allows you to add metadata information about myself as the author and the package.
-   `use_mit_license()`: adds the license.
-   `document()`: creates the documentation for package functions.
    -   Documentation for a single function is handled using `roxygen2`. Check the source code file for `strsplit1()` to see the skeleton I had to insert and edit.
    -   This then creates a helper `strsplit1.Rd` file inside the `man` directory.
-   The export directive in `NAMESPACE` is what makes `strsplit1()` available to a user after attaching regexcite via [`library(regexcite)`](https://rdrr.io/r/base/library.html). Just as it is entirely possible to author `.Rd` files “by hand”, you can manage `NAMESPACE` explicitly yourself. But we choose to delegate this to devtools (and roxygen2).
    -   This happened because the roxygen2 skeleton we inserted into the source code had the @export tag.

```{r mit_license_and_document}
# check()
check()

# use_mit_license()
use_mit_license()

# document()
document()

# second check()
check()
```

-   **2025-05-06:** Stopped at section 1.14 `install()`
-   `install()`: installs the package I just created.

```{r install}
# install()
install()

# laoding regexcite
library(regexcite)

# testing
x <- "alfa,bravo,charlie,delta"
regexcite::strsplit1(x, split = ",")

```

-   Testing seems to be the most complex topic of all with many tools coming into play.

-   `use_testthat()`: initializes the structure for testing.

-   `use_test()`: creates the test with the name we want. Ideally, that should match the name of the function.

-   The actual test itself is a simple check of whether the function generates the expected output using a simplistic example. This is done using `expect_equal()` function.

```{r use_testthat}
# initializing
use_testthat()

# creating actual test
use_test("strsplit1")

# test
test()
```

-   `use_package()`: specifies the package that we will be using functions from.

-   We then batch rename the R code file for our function and the associated test file using `rename_files()`. We then go into these files and change the source code and the affiliated tests.

-   We then call `document()` again to update the documentation and the NAMESPACE. The latter is vital to make sure that our new function names are available.

-   We then call `load_all()` to test drive the new function.

```{r use_package}
# use
use_package("stringr")

# renaming
rename_files("strsplit1", "str_split_one")

# documenting
document()

# loading again
load_all()

# testing
str_split_one(string = "a,b,c", pattern = ",") # works
str_split_one(string = c("a,b,c","d"), pattern = ",") # does not work
```

-   **2025-05-08:** Stopped at `use_github()`
-   Multiple approaches to connect my repo with GitHub. I am going to try `use_github()` here.
-   I used it and it did magic for me. It created the full GitHub repo, added its URL as my origin, and synced everything between my local analysis thusfar and the newly created GitHub repo.
    -   Phenomenal shit, and this is exactly what I intend to use for my own analysis repos as well to faciliate the creation of GitHub repos.
        -   There is a reason I was very keen to go through this book even on my day off.
-   `use_readme_rmd()`: creates an Rmd file that is then used to build my md file for the repo. Excellent for having live code and showing people general usage and installation of the package.
-   Final `check()` and `install()` to make sure everything is in order before moving on.

```{r}
# use_github()
use_github()

# use_readme_rmd()
use_readme_rmd()

# build_readme()
build_readme()

# final check
check()

# final install
install()
```

-   This is the general overview of the process.

    -   `load_all()`: makes all of the functions available so they can be tested and improved.

    -   `testthat` and `test()`: allow you to create tests and run them to ensure your packages are tested and working fine.

    -   `roxygen2`: handles documentation.

    -   Then, you commit and push to GitHub, where GitHub actions are taken.

        -   The very last step is the only mysterious bit to me.

![](images/clipboard-4036790326.png)

## Chapter Summary

-   **Note:** This summary is from the book directly, and I think it's a very good overview of everything that this chapter covered as well as the full workflow of package development.

    -   Now that I am thinking about it, the only thing I think I will struggle with is writing tests for visualisations.

    -   I do not know how people create these but I think the book will go into these aspects in more detail in later chapters.

Here is a review of the key functions you’ve seen in this chapter, organized roughly by their role in the development process.

These functions setup parts of the package and are typically called once per package:

-   [`create_package()`](https://usethis.r-lib.org/reference/create_package.html)

-   [`use_git()`](https://usethis.r-lib.org/reference/use_git.html)

-   [`use_mit_license()`](https://usethis.r-lib.org/reference/licenses.html)

-   [`use_testthat()`](https://usethis.r-lib.org/reference/use_testthat.html)

-   [`use_github()`](https://usethis.r-lib.org/reference/use_github.html)

-   [`use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html)

You will call these functions on a regular basis, as you add functions and tests or take on dependencies:

-   [`use_r()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_test()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_package()`](https://usethis.r-lib.org/reference/use_package.html)

You will call these functions multiple times per day or per hour, during development:

-   [`load_all()`](https://devtools.r-lib.org/reference/load_all.html)

-   [`document()`](https://devtools.r-lib.org/reference/document.html)

-   [`test()`](https://devtools.r-lib.org/reference/test.html)

-   [`check()`](https://devtools.r-lib.org/reference/check.html)

# Chapter 2: System Setup

-   **2025-05-10:** This is where I stopped after the end of chapter 1. Next time is the start of chapter 2
-   **Notes:** I have switched to a style of note-taking that relies on Claude to summarize the key points of the section into a few pivotal bullet points
    -   I think this is a very good way of doing it, and it is especially nice given Claude's flexibility when it comes to the formatting of the inputs
    -   Using ```` ``` ```` allows me to input markdown, which is excellent for formatting my inputs
-   **Using devtools and Its Constituent Packages**
    -   Load devtools with `library(devtools)`
    -   Access all functions directly without qualification (e.g., `load_all()`) when developing packages interactively
    -   This approach is recommended when developing packages interactively
-   **Within Package Code** - Do NOT depend on devtools in your package code - Access functions from their primary home packages (e.g., use `sessioninfo::session_info()` instead of `devtools::session_info()`)
    -   This refers to the use-case where the package being developed uses one of the functions that `devtools` makes available, in which case it is far better to reference the home package rather than `devtools` directly.
-   **Bug Reporting** - Report issues to the package that is a function's primary home - Check the help for `devtools::fcn()` to determine a function's origin
-   **Using usethis** - usethis is a notable constituent package that many developers use directly - usethis is automatically attached when you load devtools with `library(devtools)` - You can use usethis functions without qualification after loading devtools - For programmatic style, use explicit namespace: `usethis::use_testthat()`

```{r}
# preparing my system
pak::pak(
 c("devtools",
  "roxygen2",
  "testthat",
  "knitr")
)

# laoding devtools
library(devtools)

# ensuring devtools is always loaded
use_devtools()
```

-   **Personal startup configuration for devtools**

    -   Add devtools to `.Rprofile` for automatic loading in every R session

    -   Use `if (interactive()) { suppressMessages(require(devtools)) }` in `.Rprofile`

    -   The `use_devtools()` function helps set this up automatically

-   **Caution with `.Rprofile`** - Normally avoid adding packages to `.Rprofile` as it creates hidden dependencies - devtools is an exception as it's a workflow package, not for analysis scripts - Only load in interactive sessions to maintain good practices

-   **Setting your defaults in usethis** - Configure personal information in `.Rprofile` with the `options()` function - Set default author information with `"Authors@R"` containing name, email, and roles - Define preferred license with `License` option

-   **Getting development versions** - Install latest unreleased features with `devtools::install_github("r-lib/devtools")` - Alternative method using pak: `pak::pak("r-lib/devtools")`

-   **2025-05-12:** Stopped at ***2.3. R Build Toolchain***

-   **Build Toolchain Requirements:**

    -   This is only necessary for packages that use C or C++, and that's not likely anything I will be using in my development early on

    -   **Windows:** Install Rtools from CRAN (do not edit PATH; save version info to registry)

    -   **macOS:** Install Xcode command line tools (`xcode-select --install`)

    -   **Linux:** Install R development packages (e.g., `r-base-dev` on Ubuntu)

-   **Verification:**

    -   Run `devtools::dev_sitrep()` to check your development environment

    -   Update any outdated packages or dependencies as suggested

-   **Environment Checks:**

    -   `dev_sitrep()`: reports package development situation, including:

        -   R version
        -   RStudio version
        -   devtools status
        -   package dependencies

    -   This is very useful even outside of package development

```{r}
devtools::dev_sitrep()
```

# Chapter 3: Package Structure & State

-   **2025-02-13:** Finished chapter 2. Next time is the start of chapter 3

-   This is the end of a very long day today with 3 meetings, one of which was 4 hours

-   However, the satisfaction of moving forward is better than any release I get from walking away

-   **Five package states**:

    -   **Source (development form)**

    -   **Bundled**

    -   **Binary**

    -   **Installed**

    -   **In-Memory**

-   **Key transitions**:

    -   Source → Installed (`devtools::install()` or `install.packages()`)
    -   Installed → In-Memory (`library()`)

-   **2025-05-15:** Stopped at the start of bundled packages

    -   Source and package states made a lot of sense and wanted to be paying more attention when I did this

-   **Bundled packages** are compressed into `.tar.gz` files (source tarballs), serving as an intermediary between source and installed packages

-   Create bundled packages from local development using `devtools::build()`

-   **Key differences between source and bundled packages**:

    -   Vignettes are pre-built with rendered outputs in inst/doc/
    -   Temporary development files are removed
    -   Files listed in `.Rbuildignore` are excluded

-   The `.Rbuildignore` file is crucial for controlling which files from source are included in downstream forms, including **bundled**

-   Always use `usethis::use_build_ignore()` to manage `.Rbuildignore` entries because:

    -   It handles required regex anchoring automatically
    -   Regular expressions must be anchored (e.g., `^notes$` not just `notes`)
    -   Improper anchoring can unintentionally exclude important files

-   Many `usethis` functions automatically add relevant files to `.Rbuildignore` when creating them (e.g., `use_readme_rmd()`)

-   Common files to exclude via `.Rbuildignore`:

    -   Files that generate package contents (README.Rmd, data creation scripts)
    -   Development tools (RStudio project files, CI/CD configs)
    -   Documentation outside CRAN's requirements (pkgdown files)

-   Common entries in the `.Rbuildignore` file that exemplify the above file types are included below

| Pattern               | Purpose                                          |
|-----------------------|--------------------------------------------------|
| `^.*\.Rproj$`         | Designates the directory as an RStudio Project   |
| `^\.Rproj\.user$`     | Used by RStudio for temporary files              |
| `^README\.Rmd$`       | An Rmd file used to generate README.md           |
| `^LICENSE\.md$`       | Full text of the license                         |
| `^cran-comments\.md$` | Comments for CRAN submission                     |
| `^data-raw$`          | Code used to create data included in the package |
| `^pkgdown$`           | Resources used for the package website           |
| `^_pkgdown\.yml$`     | Configuration info for the package website       |
| `^\.github$`          | GitHub Actions workflows                         |

-   Following proper bundling conventions ensures compatibility with R's built-in tooling for package checking and installation

```{r}
# rbuildignore
usethis::use_build_ignore("notes.qmd")
```

-   **2025-05-16**: stopped at section 3.4 Binary Packages and very happy with this book so far
    -   I have also started to aggressively implement the new convention of ignoring full stops in my sentences
        -   If I need another sentence, I just nest it as a bullet point that flows from the preceding one

**R Binary Packages Summary**

-   **Purpose**: Binary packages (`.tgz` for macOS, `.zip` for Windows) allow distribution to users without development tools

-   **Distribution**: CRAN is the primary creator/distributor of binaries, not individual maintainers

-   **Creation**: Developers can create binaries with `devtools::build(binary = TRUE)` on the relevant OS

-   **Structure differences**: Binary packages have a transformed internal structure:

    -   R code is stored in parsed, efficient format (not as .R files)
    -   Contains `Meta/` directory with cached metadata
    -   Help content reorganized into `help`/ and `html/` folders
    -   Compiled code moved to `libs/` directory
    -   `inst/` contents moved to top-level
        -   Several development files/folders are removed

**R Installed Packages Summary**

-   **Definition**: An installed package is a binary package that's been decompressed into a package library

-   **Installation methods**: Multiple pathways exist to install packages:

    -   `R CMD INSTALL` is the underlying tool for all package installation
    -   `install.packages()` allows installation from within R sessions
    -   RStudio provides GUI options in the Build pane
    -   devtools/remotes offers specialized `install_*()` functions for various sources

-   **Challenges**: Re-installing packages already in use can be problematic:

    -   Windows users face "locked DLL" issues with compiled code
    -   Clean R sessions with minimal loaded packages recommended for troubleshooting

-   **Emerging solutions**: The `pak` package provides alternatives that:

    -   Solves the Windows "locked DLL" problem
    -   Offers advanced dependency management capabilities
    -   Is increasingly recommended for package installation tasks

![](images/clipboard-3399855533.png)

```{r}
usethis::use_git_ignore(ignores = "images/")
```

-   **2025-05-18:** Stopped at section 3.6 In-memory package

    -   Making good progress here and should more time on this to wrap it up quicker

    -   The information here is opening up a lot of discussion points and pathways I was not aware of

    -   Moving forward with these quick claude summaries and efficient reading is a very good combination

**R In-Memory Packages Summary**

-   **Package loading**: The `library()` function makes a package's functions available by loading it into memory and attaching it to the search path

-   **Development limitations**: `library()` only works with installed packages, making it inefficient for iterative development

-   **Developer alternative**: `devtools::load_all()` accelerates development by loading source packages directly into memory without requiring installation

    -   This is the default for package development, and it is a handy command to iteratively test how code changes and performs as it develops

-   **Technical distinction**: For package developers (unlike script writers), understanding the difference between loading and attaching packages is important

    -   Will be covered later in the book

-   **2025-05-19:** Stopped at package libraries

```{r}
.libPaths()
lapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)
```

**R Package Libraries Summary**

-   **Terminology clarification**:
    -   A "library" is a directory containing installed packages
    -   Common mistake: calling packages like `dplyr` "libraries" instead of "packages"
    -   Correct usage: `library()` function loads a package
-   **Multiple libraries structure**:
    -   `.libPaths()` shows active library locations
    -   Typical setup includes both user and system libraries:
        -   **User library:** contains add-on/CRAN packages (first in search path)
        -   **System library:** contains base R packages
-   **Platform differences**:
    -   **Windows:** typically has separate user/system libraries by default
    -   **macOS/Linux:** often needs manual setup of user libraries
    -   User libraries typically version-specific (need to reinstall packages after R minor version updates)
-   **Advanced library management**:
    -   Tools like `renv` manage project-specific libraries for reproducibility
    -   Methods to control libraries (from persistent to temporary):
        -   Environment variables (R_LIBS, R_LIBS_USER)
        -   `.libPaths()` function
        -   `withr::with_libpaths()` for temporary changes
        -   Function-specific arguments
-   **Critical note for developers**: Never use `library()` inside a package (packages use different dependency mechanisms than scripts)
    -   We have already seen an example of this with `regexcite` where using the `stringr` package as a dependency was executed using `usethis::use_package()`
-   **2025-05-19:** End of Chapter 3
    -   Claude summaries are excellent, and this book is exceptional
    -   Would be interested to see if there are any other books that Hadley is releasing any time soon that I could go through
    -   Every book this guy produces is golden

# Chapter 4: Fundamental Development Workflows

**Before Creating a Package**

-   Consider two types of payoff: the product itself (improved functionality) and the process (greater R mastery)
-   Survey the existing landscape to understand similar packages
-   It's valid to create your own implementation even if similar packages exist:
    -   For learning purposes
    -   If existing packages have unsuitable user interfaces or defaults
-   Study domain-specific design patterns if your work falls into a well-defined area
    -   This is highly relevant and something I already am aware of
        -   For my desired `ggtcga` package, it is commonly accepted that the input dataset is a `summarizedExperiment` object and my output is going to be DEA analysis volcano plots, feature plots, and survival plots
        -   These are the norms in the field and I intend to embrace these for my first package—I am sure there will be a lot of mistakes along the way, but experts get that way by building things
        -   I also intend to use the same conventions embraced by packages that extend `ggplot2`, such as `ggstatsplot`, and `Seurat`, such as `SCPubr`
            -   In a way, Seurat itself started off as a wrapper around `SingleCellExperiment` and `scater` that replicated their functionality and extended it by adding community detection algorithms for clustering

**Naming Your Package**

-   Formal requirements:
    -   Only letters, numbers, and periods allowed
    -   Must start with a letter
    -   Cannot end with a period
-   Best practices:
    -   Choose a unique, Google-able name
    -   Avoid names already on CRAN or Bioconductor
    -   Use all lowercase letters for memorability
        -   `ggtcga`
    -   Prioritize pronounceable names
    -   Consider modifications of words that evoke the problem
    -   Abbreviations can work well
    -   Adding an extra "R" is a common pattern
    -   Be mindful of trademark issues
-   Use the `available` package to evaluate potential names

**Creating the Package**

-   Two methods (which are actually the same):
    -   Use `usethis::create_package()`
    -   Or in RStudio: `File > New Project > New Directory > R Package`
-   Creates minimal working package with:
    -   `R/` directory
    -   Basic `DESCRIPTION` file
        -   Description of the package and its functionality
    -   Basic `NAMESPACE` file
        -   Contains the names of the functions that the package offers
    -   RStudio project file (`.Rproj`)
    -   Basic `.Rbuildignore` and `.gitignore` files
-   Avoid using `package.skeleton()` which creates problematic packages
    -   Old package development framework that is no longer relevant

**Package Location**

-   Keep source packages separate from installed packages
-   Common practice is to have a designated directory in your home folder
-   Possible organization schemes:
    -   By development role
    -   By GitHub organization
    -   By development stage
    -   By publication or data product
-   Choose a consistent organization system that works for your needs
    -   The key thing to remember is that source and installed packages should be independent from one another
    -   In my case, it is very likely that I will have them in directories inside my OneDrive, and I will develop them there
-   **2025-05-20:** Start of chapter 4 and finished section 4.1
    -   Will start on 4.2 next
    -   The combination of Claude for summaries and my note-taking after is exceptional

**Summary: RStudio Projects for R Package Development**

-   **Core Concept**: RStudio Projects work synergistically with `devtools` to create an optimal R development environment

-   A Project (capital P) is a directory with RStudio infrastructure that facilitates work on projects like R packages, data analyses, or Shiny apps

-   **Key Benefits**:

    -   **Isolation & Organization**: Each project is self-contained with no cross-contamination between different projects, even when multiple are open simultaneously

    -   **Streamlined Workflow**: Easy project launching with proper file browser and working directory setup

    -   **Enhanced Navigation**: Built-in tools like F2 (jump to function definitions) and Ctrl + . (function/file lookup)

    -   **Development Integration**: Keyboard shortcuts and clickable interfaces for common package tasks (documentation, testing, checking)

    -   **Command Access**: Command Palette (Ctrl/Cmd + Shift + P) for quick access to all IDE commands

    -   **Version Control:** built-in support with RStudio projects in the IDE that facilitates the entire process

-   **Setup Options**:

    -   **New packages**: `create_package()` automatically creates RStudio Projects

    -   **Existing packages**: File \> New Project \> Existing Directory, `create_package()` on existing directory, or `usethis::use_rstudio()`

        -   In the documentation, it is recommended to use either `create_project()` or `create_package()`

            -   Actually, `create_project()`, like `use_git()` and `use_github()`, is more useful across the board as I can use that for my analyses as well as package development

        -   Both would work better than `create_rstudio()` because they do the same thing and are more explicit about the purpose of the RStudio project

    -   **General projects**: `usethis::create_project()` for non-package projects

-   **My Experience**: I've already adopted RStudio Projects for analyses and particularly value how they maintain consistency with version control - a major workflow improvement that aligns with the isolation and organization benefits described

-   The combination of `devtools` + RStudio Projects creates a comprehensive development ecosystem that streamlines R package development from creation to deployment

-   **2025-05-22:** Stopped at section 4.2.3

    -   Brief work today as I am rather busy with preparation for Fadi's presentation

**RStudio Project Structure**

-   **Core Component**: Every RStudio Project contains a `.Rproj` file (typically named after the directory, e.g., `foo.Rproj` for directory "foo"). This is a simple text file that stores project settings and can be configured through Tools \> Project Options rather than manual editing.

-   **Best Practice**: Align naming - if your directory is "foo", the project file should be `foo.Rproj`, and if it's an R package, the package name should also be "foo". Avoid nesting packages in subdirectories to minimize friction with tools.

**Project Management**

-   **Launching Projects**: - Double-click the `.Rproj` file in your file explorer - Use File \> Open Project within RStudio - Use productivity apps/launchers for streamlined access - Multiple projects can (and should) be open simultaneously

-   **Project Alignment**: The `usethis` package assumes these three elements typically coincide: - Current RStudio Project - Active usethis project\

    -   Current working directory - Use `proj_sitrep()` to diagnose when things get out of sync

**Working Directory Philosophy**

-   **Core Principle**: Keep the top-level package directory as your working directory throughout development. Avoid constantly changing directories with `setwd()`.

-   **Why This Matters**:

-   **Explicit vs. Implicit Paths**: Write paths that clearly express intent ("read from test directory") rather than assuming current location

-   **Package State Resilience**: Packages exist in different forms during development - explicit paths work across all states

-   **Tool Compatibility**: R CMD build/check/install processes change working directories unpredictably

**Solutions**: Use path helpers like `testthat::test_path()`, `fs::path_package()`, and `rprojroot` for robust path construction.

**Development Workflow with load_all()**

-   **Central Function**: `load_all()` is the cornerstone of the devtools development cycle - it simulates installing and loading your package without actually installing it.

-   **Key Benefits**:

    -   **Rapid iteration**: Quick testing of code changes without full installation

    -   **Namespace accuracy**: Develop under realistic namespace conditions

    -   **Internal function access**: Call your own functions directly without `:::`

    -   **Dependency management**: Use imported functions without `library()` calls

    -   **Compiled code efficiency**: Especially valuable for packages with C/C++ code

-   **Usage**:

    -   **Keyboard shortcut:** Cmd+Shift+L (macOS), Ctrl+Shift+L (Windows/Linux)

    -   **RStudio Build pane**

    -   **Direct function call:** `devtools::load_all()`

-   **Development Cycle**: Edit code → `load_all()` → test → repeat

**Summary: R CMD check and Package Validation**

-   **Purpose & Importance:**

    -   R CMD check is the official validation tool for R packages

    -   Essential for CRAN submission but recommended for all packages to catch common problems early

-   **Recommended Workflow:**

    -   **Use `devtools::check()`** instead of command line R CMD check for better integration

    -   Run from R console: `devtools::check()` - RStudio shortcuts: Ctrl/Cmd + Shift + E - Available in Build menu/pane

-   **Key Philosophy: Check Early & Often**

-   **Common Mistake**: Working too long before first check, then discovering many problems

-   **Best Practice**: Check multiple times per day when actively developing

-   **Rationale**: Earlier problem detection = easier fixes

-   **What check() Does Internally**

    1.  Updates documentation via `devtools::document()`

    2.  Bundles the package for clean slate checking

    3.  Sets `NOT_CRAN` environment variable to "true"

    4.  Runs full R CMD check process

-   **Check Results Types**

    1.  **ERRORs**: Severe problems - fix regardless of CRAN plans

    2.  **WARNINGs**: Likely problems - must fix for CRAN submission

    3.  **NOTEs**: Mild issues - eliminate all for CRAN; evaluate individually if not submitting

-   **Simple Workflow**

    1.  Run `devtools::check()`

    2.  Fix first problem

    3.  Repeat until clean

-   **Direct Usage:** For advanced users: Run `R CMD check` directly in terminal on package bundles, but `devtools::check()` is preferred for development workflow integration.

-   **2025-06-05:** Finished chapter 4. A little sloppy tired because I am fasting. All done though.

# Chapter 5: The Package `Within`

Here's a brief summary of the key points covered:

-   **Main goal**: Transform a data analysis script into reusable R package components

-   **Example scenario**: Script that processes swimming survey data (location + temperature) with mixed US/UK terminology and temperature units

-   **Original script issues**: Repetitive code, copy/paste patterns, mixed code and data, inefficient practices

-   **Refactoring improvements**:

    -   Used tidyverse packages (readr, dplyr)
    -   Created lookup table for location/language mapping
        -   This was a very nice way of doing refactorization that I did not see before
            -   However, a better way to do this is using `dplyr::recode()`
    -   Extracted helper functions (f_to_c, timestamp, outfile_path)
    -   Separated data from logic
        -   The idea here is to code functions first and then use them to process the data
        -   This separation makes the code modular and reusable, and this coding style then facilitates a transition to package creation
            -   In future analyses I do, I will start embracing this style of coding a bit more where possible
                -   Might be worthwhile to create a package on top of Seurat that adds all of the Seurat options that I have been wanting
                    -   Literally building a wrapper on top of the wrapper

-   **Key lesson**: Refactoring scripts to isolate reusable data and functions makes it easier to identify components that could become a package

-   **End result**: Cleaner, more maintainable code that reveals the "package that lurks within" the original script

-   **2025-06-06:** Stopped at the start of section 5.3

**Converting Scripts to Packages - Key Points**

**The Process (Charlie → Delta → Echo → Foxtrot → Golf)**

-   **Charlie**: Start by moving reusable code and data into separate helper files
-   **Delta**: First package attempt fails - functions not exported, CSV files not accessible, dependencies not declared
-   **Echo**: Working package with proper `@export` tags, namespace-qualified function calls (`dplyr::`), and DESCRIPTION dependencies
-   **Foxtrot**: Fix build time vs. run time issues - move `Sys.time()` calls inside functions, not as top-level assignments
-   **Golf**: Handle side effects properly using `withr` package to make temporary state changes without affecting user's session

**Key Lessons: Script vs. Package**

-   **Don't convert everything**: Extract recurring operations that appear across multiple projects, not entire scripts
-   **Scripts still exist**: You'll still have R scripts, R Markdown reports, and Shiny apps - packages just make them more concise and maintainable
-   **Identify patterns**: Look for code you copy/paste between projects and operations you do repeatedly

**Key Lessons: Finding the Package Within**

-   **Start messy**: Begin with scattered, idiosyncratic scripts across different projects
-   **Notice repetition**: Identify needs that come up over and over again
-   **Refactor gradually**: Move from copy/paste to helper functions to separate files
-   **Extract when ready**: Once you have helper functions in their own file, you're ready for a package

**Key Lessons: Package Code is Different**

-   **Dependencies**: Use DESCRIPTION file and namespace-qualified calls (`pkg::function()`), not `library(pkg)` calls
-   **Data storage**: Use package-specific methods for persistent data/files, not just dumping files in the package
-   **Function visibility**: Be explicit about exports with `@export` - functions are internal by default
-   **Timing discipline**: Ensure code runs at intended time (build vs. run time) and avoid unintended side effects
-   **State management**: Use `withr` package for temporary changes to avoid affecting user's R session

**2025-06-10: End of chapter 5**

# Chapter 6: R Code

-   **All R code goes in R/ directory** as .R files

-   **Avoid extremes**: don't put all functions in one file or each function separately

-   **Group related functions**: main function with helpers or function families

-   **Use meaningful file names** that convey which functions are inside

-   **Create R/utils.R** for small utilities used across multiple functions

-   **Use `devtools::load_all()`** for fast feedback instead of sourcing files

-   **Follow tidyverse style guide** and use *styler package* to enforce it automatically

-   **RStudio shortcuts**: *Ctrl + .* for Go to File/Function, *F2* to jump to function definition

-   **Development workflow**: `load_all()`, `test()`, and `check()` for package development

**2025-06-17: Stopped at the start of section 6.4**

**When Code Executes:**

-   Package code runs at build time (when the package is created), not when users load it - this means objects are cached from the build environment, which can cause problems if build and user environments differ

**Write Functions, Not Top-Level Code:**

-   Any R code outside of functions is suspicious - instead of creating objects at the package level, wrap that logic in functions that execute at runtime when users actually call them

**Don't Modify the Global Environment:**

-   Avoid functions like `library()`, `require()`, `source()`, `setwd()`, `options()`, and `par()` that change global settings - if you must use them, clean up afterwards using tools like the withr package

**Don't Assume User Environment:**

-   Your functions will run on different systems with different locales, working directories, and settings than yours - write defensive code that doesn't rely on specific environmental assumptions

**Real-World Examples:**

-   File paths from `system.file()` that work during build but fail on user machines, color display objects cached from headless build servers, and function aliases that get stuck with old buggy versions all illustrate these principles

The core principle is that package code should create reusable functions that work reliably across different environments, not execute specific logic that gets baked in at build time.

**2025-06-17: Stopped at the start of section 6.5.1**

**Managing State**

-   Use **withr package** or **`on.exit()`** to restore environment changes when functions exit

-   **withr helpers:** `with_*()` for code snippets, `local_*()` for function-duration changes

-   Always use **add = TRUE** with `on.exit()`

**Side Effects**

-   **Isolate** plotting/output into dedicated functions

-   Use **`.onLoad()`/`.onAttach()`** for package initialization

-   **Prefix package options** with package name

**Development Workflow**

-   **Iterate frequently:** Edit → `document()` → `load_all()` → `test()` → `check()`

-   **Run checks often** - don't wait until end

**CRAN Requirements**

-   **ASCII characters only** in .R files

-   Use **Unicode escapes** like "\u2022" for special characters

-   Check for hidden non-ASCII with **tools::showNonASCII()**

**2025-07-30:** Chapter 6 is complete and starting chapter 7 next time

-   I am thinking I should start package development soon because I feel like I am getting bogged down in useless details instead of learning the actual process by doing

-   I just want to finish the next chapter about working with data inside the R package before starting because I will need test data and the sample development workflow they showed me in chapter 1 did not use any external data

-   This chapter however has been very cryptic and the advice mostly pertains to shit that I am not going to be dealing with in the early stages of development

# Chapter 7: Data

**Data in R Packages**

**Storage Locations**

-   **`data/`**: User-accessible data as `.rda` files (most common)
-   **`R/sysdata.rda`**: Internal data for package functions
-   **`inst/extdata/`**: Raw files (CSV, Excel, etc.)
-   **Environments**: Dynamic session-specific data
-   **Sanctioned locations**: Persistent cross-session data

**Main Workflow with `data/`**

-   Use `usethis::use_data(my_data)` to automatically:
    -   Save as `data/my_data.rda`
    -   Enable lazy loading via `LazyData: true` in DESCRIPTION
    -   Make data available as `pkg::my_data` or `my_data` after `library(pkg)`
-   Lazy loading = data only loads when accessed, saving memory
-   Avoid unnecessary `data()` calls - data is immediately available

**Data Preparation**

-   Keep data-generating code in `data-raw/` (use `usethis::use_data_raw()`)
-   Scripts in `data-raw/` should end with `usethis::use_data()` call to then add the data being generated as `rda` files under the `data/` directory
-   Enables reproducible data reconstruction

**Documentation (Required)**

-   Document in `R/data.R` using roxygen2
-   **Key tags:** `@format` (structure/variables), `@source` (origin)
-   Never use `@export` for datasets

**Technical Notes**

-   **Size**: \<1MB for CRAN
-   **Compression**: Default "bzip2", experiment with "gzip"/"xz"
-   **Encoding**: UTF-8 for non-ASCII (generates harmless CRAN notes)
-   **Best practice**: One object per `.rda` file with matching names

**Key Benefit**

The `devtools`/`usethis` ecosystem reduces complex package data workflows to simple function calls, making development structured and maintainable

**2025-07-31:** Stopped at section 7.2, and this chapter is very good imo with lots of important points that are vital for my package development

**Internal Data (R/sysdata.rda)**

**Purpose & Storage**

-   Use `R/sysdata.rda` for internal data that package functions need but users shouldn't access

-   For large/complex objects too big to define directly in R code

**Creation & Management:**

-   Create with `usethis::use_data(internal = TRUE)` - puts all internal objects in one file
-   Store generation code in `data-raw/`, not `R/`
-   Available to package functions, tests, and after `devtools::load_all()`

**Key Differences from External Data:**

-   No documentation needed (not exported)
-   Always lazy-loaded regardless of `LazyData` field
-   All objects in one file vs. separate files for external data

**Raw Data Files (inst/extdata/)**

**Purpose & Location:**

-   Store original/raw files in `inst/extdata/` for examples and demos
-   Files move to `extdata/` when package is installed
-   Main use: when package functionality acts on external files

**Common Use Cases:**

-   File parsing packages (readr, readxl, xml2, archive)
-   Data packages providing multiple formats (palmerpenguins, gapminder with CSV versions)

**Benefits:**

-   Useful for documentation and tests
-   Helps teaching with familiar datasets
-   Plain text versions track data changes over time

**2025-08-04:** stopped at section 7.3.1

-   I am starting to think it could be a very good idea to start creating a very small package of helpful utilities and functions that I have to iterate through often for scRNA-Seq analysis

    -   What I have in mind are custom versions of `SCPubr` functions that include my most used settings, a simpler `ggsave` call that uses pdf by default and uses large width and height parameters out of the box, and a GSEA barplot figure that is way better than the shit `clusterprofiler` spits out

    -   Will start working on that some time towards the end of this week to start getting some real hands-on experience with package development

        -   Maybe, this shit works, and I finally have something new that is enhancing my workflows

            -   Imagine having helper scripts that contain my preferred presets and wrapping these into packages of my own making

                -   Now that would be fun and interesting and would add a lot to my computational skillset

**Remainder of Chapter 7**

-   `inst/` directory contains supporting stuff that does not go into `R/`, `data/`, or `vignettes/`

-   Section 7.3 is frankly too technical and thus a waste of time—I have gone through it briefly and the details are just too boring at this point

-   Gone through the rest of the chapter and frankly all of this stuff is far too technical my g

-   Chapter 7 is done

    -   I tried summarizing the chapter using chatGPT, and it seems to do a better job on summaries than claude

        -   When the time comes for my package development work, I will create a more concise version of these notes that only included the most key points

# Chapter 8: Other Components

**📦 Beginner-Friendly Summary of Miscellaneous Package Components**

Chapter 8 of *R Packages* introduces **less common package directories**. Most are optional for beginners, but here’s what matters:

**1️⃣ `src/`: Source**

-   Holds **compiled code** (C or C++).
-   Boosts performance or uses external libraries.
-   **Ignore for now** unless you move into C++ or heavy performance work.

**2️⃣ `inst/`: Install**

-   Holds **extra files you want included** in the **installed** package.

    -   Installed is the key word here.

-   **All files move to the root** of the package when installed.

-   Common uses:

    -   `inst/extdata/` → raw example files (CSV, FASTQ, etc.)
    -   `inst/CITATION` → how to cite the package
    -   `inst/rmarkdown/templates/` → custom R Markdown templates
    -   RStudio add-ins or Shiny examples

-   ⚡ **Think of it as a “misc storage” folder for user-accessible files.**

**3️⃣ `tools/`**

-   Holds **auxiliary build or config files** (often with `configure`).
-   **Advanced only**; safe to ignore for now.

**4️⃣ `demo/`**

-   For **legacy demos**.
-   Modern practice → use **vignettes** or **README examples** instead.

**5️⃣ `exec/`**

-   For **executable scripts**, automatically flagged as executable.
-   Rarely used; modern practice often prefers `inst/`.

**6️⃣ `po/`**

-   For **translations (internationalization)**.
-   Advanced topic; **ignore for now**.

**💡 Beginner Takeaways**

-   **Focus on `inst/`** for any extra files like raw data or templates.
-   **Ignore `src/`, `tools/`, `demo/`, `exec/`, and `po/`** until your package grows.
-   **Prefer vignettes and README over demos**, and **`inst/extdata`** for raw example files.

**2025-08-05:** Chapter 8 is over, and I am starting to aggressively move through the book and ignore bits and pieces that I think are useless

-   Whilst the explanation of the book is to-the-point, there is a lot of extra stuff that is not necessary for a beginner

    -   That's why I am skipping that shit and moving forward

# Chapter 9: DESCRIPTION

📦 **Key Points About DESCRIPTION**

-   **Purpose**:

    -   Defines your package as an R package (any folder with a DESCRIPTION is a package).
    -   Stores **metadata**: name, version, authors, dependencies, URLs, and license.

-   **Essential Fields**:

    1.  **Package** – Short, unique name of your package.

    2.  **Title** – One-line, title case, no period; describes what the package does.

    3.  **Description** – One-paragraph explanation of the package; indent multi-line entries.

    4.  **Version** – Use `0.0.0.9000` for development versions.

    5.  **Authors\@R** – Use `person()` function to list authors/maintainers with roles:

        -   `cre` = maintainer (must have email)
        -   `aut` = main authors
        -   `ctb` = contributors

    6.  **License** – Mandatory, use a standard form (`use_mit_license()`, `use_gpl3_license()`).

    7.  **URL / BugReports** – Link to website, repo, and issue tracker (auto-added by `usethis::use_github()`).

-   **Formatting Tips**:

    -   Use **single quotes** around R packages or software names.
    -   Avoid “A package for …” in Title or Description.
    -   Description lines ≤80 characters; indent subsequent lines by 4 spaces.
    -   **CRAN checks** pay special attention to Title, Description, and License.

-   **Tools to Help**:

    -   `usethis::create_package()` → Generates minimal DESCRIPTION.
    -   `desc` package → Edit DESCRIPTION programmatically.
    -   `usethis::use_github()` → Adds URL and BugReports automatically.

**2025-08-06:** Stopped at section 9.6 because it's important and needs my full attention—I also got a bit bored as I usually do

-   Continuing with the pattern of dashing through chapters, this one is going by quickly even though it is very useful

    -   Easier to do work quickly on two cups of coffee

        -   Who would have thought?!

**📦 `DESCRIPTION` File: Imports, Suggests & Other Fields**

**✅ Core Dependency Fields**

-   **`Imports:`**

    -   Required **at runtime**.

    -   Automatically installed with your package.

    -   Example:

        ``` r
        Imports:
            dplyr,
            tidyr
        ```

    -   You will note here that package version is not specified, so I can create my own packages and use them with whatever version of these packages that I have

        -   There is also the option to specify a minimum version of the package, so that's there to for when I am officially developing packages for release to the public

-   **`Suggests:`**

    -   Optional packages for **development**, testing, or extended features.

    -   Not required for basic functionality.

    -   Example:

        ``` r
        Suggests:
            ggplot2,
            testthat
        ```

-   Use `usethis::use_package("pkg")` to add packages cleanly.

    -   Defaults to `Imports`.
    -   Use `"Suggests"` explicitly if needed in the `type` argument of `use_package()`.

🔢 **Minimum Versions**

-   Specify with parentheses: `dplyr (>= 1.0.0)`
-   Avoid `==` (exact match) — too rigid.
-   Use `usethis::use_package("pkg", min_version = TRUE)` to lock to your current version if needed.
-   Be **cautious**: Setting higher version requirements may cause install issues for others.

❌ **Other Dependency Fields (Use Rarely)**

-   **`Depends:`**

    -   Avoid unless setting R version: `Depends: R (>= 4.0.0)`
    -   `Imports` is preferred.

-   **`LinkingTo:`**

    -   For packages using C/C++ from other packages.

-   **`Enhances:`**

    -   Used to signal your package adds features to another. Rarely used.

⚠️ **R Version Gotcha**

-   `.rds` files saved in R ≥ 3.6.0 use serialization **version 3**, unreadable by R \< 3.5.0.
-   Can **silently bump** R version in DESCRIPTION.
-   Be deliberate with `.rds` file formats to avoid unexpected version dependencies.

📄 **Other Common Fields**

-   **`Version:`**

    -   Tracks the version of your package.

-   **`LazyData:`**

    -   Makes package datasets auto-available without `data()`.

-   **`Encoding:`**

    -   Usually set to `UTF-8`.

-   **`Collate:`**

    -   Controls order of R file loading; used for S4 classes.

-   **`VignetteBuilder:`**

    -   Declares which vignette engine to use (e.g., `knitr`).

-   **`SystemRequirements:`**

    -   Declares external software needed (e.g., `C++17`, `TensorFlow`).
    -   Does not install anything, so further information should be added to README to specify installation instructions

🛠️ **Custom Fields**

-   Use `Config/*` prefix for any **custom metadata**.
-   Avoid redefining official field names.
-   Example: `Config/Needs/website`

✍️ **roxygen2 Fields**

-   Generated by `create_package()`:

    -   `Roxygen: list(markdown = TRUE)`
    -   `RoxygenNote: <version>`

-   Related to documentation setup.

**2025-08-07:** Chapter 9 over and continuing the quick move through the book

-   Again, working on two cups of coffee hits different

# Chapter 10: Dependencies — Mindset & Background

-   **When to add dependencies:** Framework for deciding if a dependency is worth the risk/reward
-   **Dependency types:** Guidance on choosing between `Imports`, `Suggests`, and `Depends`
-   **Namespaces:** How R's namespace system prevents package conflicts and ensures consistent behavior
-   **Beginner-friendly:** Can skip initially but important for more complex packages

**2025-08-13:** Stopped at the beginning of chapter 10.1

-   Very little progress today as I am operating on very little sleep and wanted to simply start the chapter without pushing too far in it

**Low-cost dependencies:**

-   Base R packages (`base`, `utils`, `stats`) and recommended packages
-   Packages with few upstream dependencies (like `rlang`)
-   Already-installed popular packages (like `ggplot2`)

**High-cost dependencies:**

-   Non-CRAN packages requiring special setup

-   Packages with many recursive dependencies (\~250+)

-   Large/slow-compiling packages (some take 100+ seconds vs 5 seconds)

-   Packages requiring system dependencies (Java, external libraries)

**Key factors:** Installation burden, maintenance quality, and functionality value all matter more than just counting total number of dependencies.

**2025-08-14:** stopped at section 10.1.2

-   Progress is a bit slow this week due to turbulanecs

**Dependency Philosophy**

-   **Take a holistic approach** - Consider your audience (package authors need lean packages, data scientists can handle more dependencies)
-   **Balance trade-offs** - Dependencies give you features/bug fixes but cost installation time, disk space, and maintenance burden
-   **Be quantitative** - Use tools like `pak::pkg_deps_tree()` to analyze dependency weight rather than just minimizing count

**Tidyverse-Specific Guidelines**

-   **Never depend on meta-packages** - Don't put `tidyverse` or `devtools` in Imports; depend on specific packages instead
    -   I did see that as a warning when I was developing my own package
-   **"Free" dependencies** - `rlang`, `cli`, `glue`, `withr`, `lifecycle` are considered lightweight and acceptable
-   **Easy setup** - Use `usethis::use_tidy_dependencies()` to add these core tidyverse dependencies to your DESCRIPTION
-   **CRAN limit** - Avoid 20+ non-default packages in Imports (triggers a NOTE)
    -   Try to handle all notes in your package before submission and in general

**Imports vs Suggests**

-   **Imports** - Required packages that auto-install with your package
-   **Suggests** - Optional packages for tests, vignettes, or rare functions; users must install separately
    -   Early stages of package development do not usually require Suggests at all, so put everything you need in Imports, especially since my audience is other bioinformaticians rather than package developers

**Namespaces (10.2.1 Simplified)**

-   **Problem**: Multiple packages can have functions with the same name (e.g., `lubridate::here()` vs `here::here()`)
-   **Solution**: Use `package::function()` syntax to specify exactly which function you want
    -   This is already the default behaviour I am using in all of my package scripting
-   **Key insight**: Package functions are protected from user interference - even if you redefine `var()`, `sd()` still works because it looks in the `stats` namespace first, not your global environment
-   **Bottom line**: Namespaces prevent chaos by ensuring package functions always find their intended dependencies

**2025-08-18: Stopped at section 10.2.2**

-   Brisk progress today as this is becoming more relevant for my own real-life package development with `BadranSeq` and the package I am keen to develop for my brother's analysis

**R Package Namespaces Summary**

**NAMESPACE file**: Defines what your package exports (for users) and imports (from other packages). Usually auto-generated by roxygen2.

**Function lookup**:

-   User code searches global environment → attached packages (can cause conflicts)

-   Package code uses isolated namespaces (prevents conflicts)

**Loading vs Attaching**:

-   Loading: Makes package available in memory

-   Attaching: Adds to search path (what `library()` does)

**Key rule**: Use `Imports` (not `Depends`) in DESCRIPTION to load packages without cluttering users' search path.

# Chapter 11: Dependencies — In Practice

-   **`Imports` in DESCRIPTION** ≠ importing functions (just ensures packages get installed)

-   **To actually use functions**: Need NAMESPACE directives (`import()`/`importFrom()`) OR `::` notation

-   **Rule**: All packages in NAMESPACE must be in DESCRIPTION, but not vice versa

-   **Common pattern**: Package listed in `Imports` but not in NAMESPACE

    -   I can vouch for this because almost all of my packages in `Imports` under DESCRIPTION are not in the NAMESPACE file and are referred to in my package source code under `R/` using `::`
