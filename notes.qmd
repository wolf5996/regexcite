---
title: "Package Development"
author: "Badran Elshenawy"
date: 2025-04-25T12:00:00Z
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 2
    self-contained: true
    title-block-banner: true
---

# Context

-   Working with TCGA data, I came to the realization that TCGA lacks good visualisation packages. I can create my own package, and that would be a solid publication on its own.

-   What I will do now is go through [R packages (2e)](https://r-pkgs.org/) to learn the basics of package development in general and for R specifically.

-   I will then use my own skills in combination with ChatGPT/LLMs to create a full package with documentation.

-   This is a side project that I anticipate will take several months to complete‚Äîit will teach me an immense amount about software development and has the potential to boost my CV with a full package of my own.

-   For my note-taking style, I will try to be more chill and focus on the actual book.

    -   Do not intend to include a massive amount of notes and use this document as a comprehensive reference.

    -   This is just a few points I will jot down as I go through the book. I think I value consuming the information and understanding it more than I do note-taking at this current stage of my development.

-   During my work on this book, I thought about switching a bit towards Quarto or positron for this guide.

    -   However, I think that's a poor idea because this book clearly states that it is designed to work with RStudio, which has a host of functions and utilities built-in that are meant to make the process of package development smooth.

-   The final evolution of this is going to be a ChatGPT or Claude project where each thread handles an aspect of the package, and I will be using that to create my own ggTCGA package.

    -   I can then use this package internally for my own analysis of TCGA data and publish the package as a paper on biorevix.

        -   This is a solid plan and one that I think holds immense value for me.

            -   If you are wondering why other people would not do the same thing, well it's because they do not have the foresight needed to learn fundamentals and the vision necessary to execute on these using LLMs to handle details and using their brains to handle higher level management of LLM performance and abstraction.

-   Another important side project I can do is a small package containing helper functions I use

    -   These are going to be the same visualisation functions I use but with my preferred presets

    -   The idea here is to create a very simple package that I can use myself, thereby familiarizing myself with the developer and user sides of the package

# Notes

-   Throughout this book:

    -   `fun()` refers to functions.

    -   `var` refers to variables and function arguments.

    -   `path/` for paths.

-   **2025-04-25:** Finished welcome and preface. Will start at introduction next time. Should check for a pirated PDF version.

-   **2025-04-28:** Read the **`Introduction`**. Will start at **`The Whole Game`** next time.

# Chapter 1: The Whole Game

-   **Note:** setting WD is not necessary here at all, and the reason is that R projects set the working directory automatically.

-   Will walk through the development of a toy package called `regexcite`.

-   Should embody all the steps of package developments, which future chapters will delve into in more detail.

```{r}
# setwd
# setwd(
#   dirname(
#     rstudioapi::getActiveDocumentContext()$path
#   )
# )
# libraries
library(devtools)
packageVersion("devtools")

# creating the package
# create_package(
#   path = "regexcite"
# )
```

-   This code creates a directory which will contain my package and opens a new R session relating to the package R project.

-   The relevant files created by this are:

    -   `.Rbuildignore` lists files that we need to have around but that should not be included when building the R package from source. If you aren‚Äôt using RStudio, [`create_package()`](https://usethis.r-lib.org/reference/create_package.html) may not create this file (nor `.gitignore`) at first, since there‚Äôs no RStudio-related machinery that needs to be ignored. However, you will likely develop the need for `.Rbuildignore` at some point, regardless of what editor you are using. It is discussed in more detail in [Section 3.3.1](https://r-pkgs.org/structure.html#sec-rbuildignore).

    -   `.Rproj.user`, if you have it, is a directory used internally by RStudio.

    -   `.gitignore` anticipates Git usage and tells Git to ignore some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.

    -   `DESCRIPTION` provides metadata about your package. We edit this shortly and [Chapter 9](https://r-pkgs.org/description.html) covers the general topic of the `DESCRIPTION` file.

    -   `NAMESPACE` declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.

    -   The `R/` directory is the ‚Äúbusiness end‚Äù of your package. It will soon contain `.R` files with function definitions.

    -   `regexcite.Rproj` is the file that makes this directory an RStudio Project. Even if you don‚Äôt use RStudio, this file is harmless. Or you can suppress its creation with `create_package(..., rstudio = FALSE)`. More in [Section 4.2](https://r-pkgs.org/workflow101.html#sec-workflow101-rstudio-projects).

-   **2025-04-30:** finished sections 1.1-1.4. Will start on section 1.5 (`use_git()`) tomorrow.

    -   So far, the process seems very nice and straightforward.

-   The regexcite directory is an **`R source package`** and **`an RStudio Project`**. The next command will also turn it into a `git` repository.

-   `use_r()`: opens an R script inside `R/` where I can put my function definition. The name of the R script is the argument input to `use_r` and should be the same as the name of the function.

-   `load_all()`: loads all of the functions defined in the package without actually adding them to the global env. Good way of testing the package as it matures.

```{r git_function_creation_loading}
# using git in the repo project/directory
use_git()

# coding the first function
strsplit1 <- function(x, split){
  strsplit(x, split = split)[[1]]
}

# use_r()
use_r("strsplit1")

# load_all()
load_all()

# example test
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")

# checking for existence in global env
exists(
  "strsplit1",
  where = globalenv(),
  inherits = FALSE
)

```

-   **2025-05-01:** stopped at section 1.9 `check()`.
-   `check()`: checks that your package is still in working order.
-   `CTRL` + `.`: excellent keyboard shortcut to go to any other file in your project and open it in Rstudio.
-   Editing Description is easy and allows you to add metadata information about myself as the author and the package.
-   `use_mit_license()`: adds the license.
-   `document()`: creates the documentation for package functions.
    -   Documentation for a single function is handled using `roxygen2`. Check the source code file for `strsplit1()` to see the skeleton I had to insert and edit.
    -   This then creates a helper `strsplit1.Rd` file inside the `man` directory.
-   The export directive in `NAMESPACE` is what makes `strsplit1()` available to a user after attaching regexcite via [`library(regexcite)`](https://rdrr.io/r/base/library.html). Just as it is entirely possible to author `.Rd` files ‚Äúby hand‚Äù, you can manage `NAMESPACE` explicitly yourself. But we choose to delegate this to devtools (and roxygen2).
    -   This happened because the roxygen2 skeleton we inserted into the source code had the @export tag.

```{r mit_license_and_document}
# check()
check()

# use_mit_license()
use_mit_license()

# document()
document()

# second check()
check()
```

-   **2025-05-06:** Stopped at section 1.14 `install()`
-   `install()`: installs the package I just created.

```{r install}
# install()
install()

# laoding regexcite
library(regexcite)

# testing
x <- "alfa,bravo,charlie,delta"
regexcite::strsplit1(x, split = ",")

```

-   Testing seems to be the most complex topic of all with many tools coming into play.

-   `use_testthat()`: initializes the structure for testing.

-   `use_test()`: creates the test with the name we want. Ideally, that should match the name of the function.

-   The actual test itself is a simple check of whether the function generates the expected output using a simplistic example. This is done using `expect_equal()` function.

```{r use_testthat}
# initializing
use_testthat()

# creating actual test
use_test("strsplit1")

# test
test()
```

-   `use_package()`: specifies the package that we will be using functions from.

-   We then batch rename the R code file for our function and the associated test file using `rename_files()`. We then go into these files and change the source code and the affiliated tests.

-   We then call `document()` again to update the documentation and the NAMESPACE. The latter is vital to make sure that our new function names are available.

-   We then call `load_all()` to test drive the new function.

```{r use_package}
# use
use_package("stringr")

# renaming
rename_files("strsplit1", "str_split_one")

# documenting
document()

# loading again
load_all()

# testing
str_split_one(string = "a,b,c", pattern = ",") # works
str_split_one(string = c("a,b,c","d"), pattern = ",") # does not work
```

-   **2025-05-08:** Stopped at `use_github()`
-   Multiple approaches to connect my repo with GitHub. I am going to try `use_github()` here.
-   I used it and it did magic for me. It created the full GitHub repo, added its URL as my origin, and synced everything between my local analysis thusfar and the newly created GitHub repo.
    -   Phenomenal shit, and this is exactly what I intend to use for my own analysis repos as well to faciliate the creation of GitHub repos.
        -   There is a reason I was very keen to go through this book even on my day off.
-   `use_readme_rmd()`: creates an Rmd file that is then used to build my md file for the repo. Excellent for having live code and showing people general usage and installation of the package.
-   Final `check()` and `install()` to make sure everything is in order before moving on.

```{r}
# use_github()
use_github()

# use_readme_rmd()
use_readme_rmd()

# build_readme()
build_readme()

# final check
check()

# final install
install()
```

-   This is the general overview of the process.

    -   `load_all()`: makes all of the functions available so they can be tested and improved.

    -   `testthat` and `test()`: allow you to create tests and run them to ensure your packages are tested and working fine.

    -   `roxygen2`: handles documentation.

    -   Then, you commit and push to GitHub, where GitHub actions are taken.

        -   The very last step is the only mysterious bit to me.

![](images/clipboard-4036790326.png)

## Chapter Summary

-   **Note:** This summary is from the book directly, and I think it's a very good overview of everything that this chapter covered as well as the full workflow of package development.

    -   Now that I am thinking about it, the only thing I think I will struggle with is writing tests for visualisations.

    -   I do not know how people create these but I think the book will go into these aspects in more detail in later chapters.

Here is a review of the key functions you‚Äôve seen in this chapter, organized roughly by their role in the development process.

These functions setup parts of the package and are typically called once per package:

-   [`create_package()`](https://usethis.r-lib.org/reference/create_package.html)

-   [`use_git()`](https://usethis.r-lib.org/reference/use_git.html)

-   [`use_mit_license()`](https://usethis.r-lib.org/reference/licenses.html)

-   [`use_testthat()`](https://usethis.r-lib.org/reference/use_testthat.html)

-   [`use_github()`](https://usethis.r-lib.org/reference/use_github.html)

-   [`use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html)

You will call these functions on a regular basis, as you add functions and tests or take on dependencies:

-   [`use_r()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_test()`](https://usethis.r-lib.org/reference/use_r.html)

-   [`use_package()`](https://usethis.r-lib.org/reference/use_package.html)

You will call these functions multiple times per day or per hour, during development:

-   [`load_all()`](https://devtools.r-lib.org/reference/load_all.html)

-   [`document()`](https://devtools.r-lib.org/reference/document.html)

-   [`test()`](https://devtools.r-lib.org/reference/test.html)

-   [`check()`](https://devtools.r-lib.org/reference/check.html)

# Chapter 2: System Setup

-   **2025-05-10:** This is where I stopped after the end of chapter 1. Next time is the start of chapter 2
-   **Notes:** I have switched to a style of note-taking that relies on Claude to summarize the key points of the section into a few pivotal bullet points
    -   I think this is a very good way of doing it, and it is especially nice given Claude's flexibility when it comes to the formatting of the inputs
    -   Using ```` ``` ```` allows me to input markdown, which is excellent for formatting my inputs
-   **Using devtools and Its Constituent Packages**
    -   Load devtools with `library(devtools)`
    -   Access all functions directly without qualification (e.g., `load_all()`) when developing packages interactively
    -   This approach is recommended when developing packages interactively
-   **Within Package Code** - Do NOT depend on devtools in your package code - Access functions from their primary home packages (e.g., use `sessioninfo::session_info()` instead of `devtools::session_info()`)
    -   This refers to the use-case where the package being developed uses one of the functions that `devtools` makes available, in which case it is far better to reference the home package rather than `devtools` directly.
-   **Bug Reporting** - Report issues to the package that is a function's primary home - Check the help for `devtools::fcn()` to determine a function's origin
-   **Using usethis** - usethis is a notable constituent package that many developers use directly - usethis is automatically attached when you load devtools with `library(devtools)` - You can use usethis functions without qualification after loading devtools - For programmatic style, use explicit namespace: `usethis::use_testthat()`

```{r}
# preparing my system
pak::pak(
 c("devtools",
  "roxygen2",
  "testthat",
  "knitr")
)

# laoding devtools
library(devtools)

# ensuring devtools is always loaded
use_devtools()
```

-   **Personal startup configuration for devtools**

    -   Add devtools to `.Rprofile` for automatic loading in every R session

    -   Use `if (interactive()) { suppressMessages(require(devtools)) }` in `.Rprofile`

    -   The `use_devtools()` function helps set this up automatically

-   **Caution with `.Rprofile`** - Normally avoid adding packages to `.Rprofile` as it creates hidden dependencies - devtools is an exception as it's a workflow package, not for analysis scripts - Only load in interactive sessions to maintain good practices

-   **Setting your defaults in usethis** - Configure personal information in `.Rprofile` with the `options()` function - Set default author information with `"Authors@R"` containing name, email, and roles - Define preferred license with `License` option

-   **Getting development versions** - Install latest unreleased features with `devtools::install_github("r-lib/devtools")` - Alternative method using pak: `pak::pak("r-lib/devtools")`

-   **2025-05-12:** Stopped at ***2.3. R Build Toolchain***

-   **Build Toolchain Requirements:**

    -   This is only necessary for packages that use C or C++, and that's not likely anything I will be using in my development early on

    -   **Windows:** Install Rtools from CRAN (do not edit PATH; save version info to registry)

    -   **macOS:** Install Xcode command line tools (`xcode-select --install`)

    -   **Linux:** Install R development packages (e.g., `r-base-dev` on Ubuntu)

-   **Verification:**

    -   Run `devtools::dev_sitrep()` to check your development environment

    -   Update any outdated packages or dependencies as suggested

-   **Environment Checks:**

    -   `dev_sitrep()`: reports package development situation, including:

        -   R version
        -   RStudio version
        -   devtools status
        -   package dependencies

    -   This is very useful even outside of package development

```{r}
devtools::dev_sitrep()
```

# Chapter 3: Package Structure & State

-   **2025-02-13:** Finished chapter 2. Next time is the start of chapter 3

-   This is the end of a very long day today with 3 meetings, one of which was 4 hours

-   However, the satisfaction of moving forward is better than any release I get from walking away

-   **Five package states**:

    -   **Source (development form)**

    -   **Bundled**

    -   **Binary**

    -   **Installed**

    -   **In-Memory**

-   **Key transitions**:

    -   Source ‚Üí Installed (`devtools::install()` or `install.packages()`)
    -   Installed ‚Üí In-Memory (`library()`)

-   **2025-05-15:** Stopped at the start of bundled packages

    -   Source and package states made a lot of sense and wanted to be paying more attention when I did this

-   **Bundled packages** are compressed into `.tar.gz` files (source tarballs), serving as an intermediary between source and installed packages

-   Create bundled packages from local development using `devtools::build()`

-   **Key differences between source and bundled packages**:

    -   Vignettes are pre-built with rendered outputs in inst/doc/
    -   Temporary development files are removed
    -   Files listed in `.Rbuildignore` are excluded

-   The `.Rbuildignore` file is crucial for controlling which files from source are included in downstream forms, including **bundled**

-   Always use `usethis::use_build_ignore()` to manage `.Rbuildignore` entries because:

    -   It handles required regex anchoring automatically
    -   Regular expressions must be anchored (e.g., `^notes$` not just `notes`)
    -   Improper anchoring can unintentionally exclude important files

-   Many `usethis` functions automatically add relevant files to `.Rbuildignore` when creating them (e.g., `use_readme_rmd()`)

-   Common files to exclude via `.Rbuildignore`:

    -   Files that generate package contents (README.Rmd, data creation scripts)
    -   Development tools (RStudio project files, CI/CD configs)
    -   Documentation outside CRAN's requirements (pkgdown files)

-   Common entries in the `.Rbuildignore` file that exemplify the above file types are included below

| Pattern               | Purpose                                          |
|-----------------------|--------------------------------------------------|
| `^.*\.Rproj$`         | Designates the directory as an RStudio Project   |
| `^\.Rproj\.user$`     | Used by RStudio for temporary files              |
| `^README\.Rmd$`       | An Rmd file used to generate README.md           |
| `^LICENSE\.md$`       | Full text of the license                         |
| `^cran-comments\.md$` | Comments for CRAN submission                     |
| `^data-raw$`          | Code used to create data included in the package |
| `^pkgdown$`           | Resources used for the package website           |
| `^_pkgdown\.yml$`     | Configuration info for the package website       |
| `^\.github$`          | GitHub Actions workflows                         |

-   Following proper bundling conventions ensures compatibility with R's built-in tooling for package checking and installation

```{r}
# rbuildignore
usethis::use_build_ignore("notes.qmd")
```

-   **2025-05-16**: stopped at section 3.4 Binary Packages and very happy with this book so far
    -   I have also started to aggressively implement the new convention of ignoring full stops in my sentences
        -   If I need another sentence, I just nest it as a bullet point that flows from the preceding one

**R Binary Packages Summary**

-   **Purpose**: Binary packages (`.tgz` for macOS, `.zip` for Windows) allow distribution to users without development tools

-   **Distribution**: CRAN is the primary creator/distributor of binaries, not individual maintainers

-   **Creation**: Developers can create binaries with `devtools::build(binary = TRUE)` on the relevant OS

-   **Structure differences**: Binary packages have a transformed internal structure:

    -   R code is stored in parsed, efficient format (not as .R files)
    -   Contains `Meta/` directory with cached metadata
    -   Help content reorganized into `help`/ and `html/` folders
    -   Compiled code moved to `libs/` directory
    -   `inst/` contents moved to top-level
        -   Several development files/folders are removed

**R Installed Packages Summary**

-   **Definition**: An installed package is a binary package that's been decompressed into a package library

-   **Installation methods**: Multiple pathways exist to install packages:

    -   `R CMD INSTALL` is the underlying tool for all package installation
    -   `install.packages()` allows installation from within R sessions
    -   RStudio provides GUI options in the Build pane
    -   devtools/remotes offers specialized `install_*()` functions for various sources

-   **Challenges**: Re-installing packages already in use can be problematic:

    -   Windows users face "locked DLL" issues with compiled code
    -   Clean R sessions with minimal loaded packages recommended for troubleshooting

-   **Emerging solutions**: The `pak` package provides alternatives that:

    -   Solves the Windows "locked DLL" problem
    -   Offers advanced dependency management capabilities
    -   Is increasingly recommended for package installation tasks

![](images/clipboard-3399855533.png)

```{r}
usethis::use_git_ignore(ignores = "images/")
```

-   **2025-05-18:** Stopped at section 3.6 In-memory package

    -   Making good progress here and should more time on this to wrap it up quicker

    -   The information here is opening up a lot of discussion points and pathways I was not aware of

    -   Moving forward with these quick claude summaries and efficient reading is a very good combination

**R In-Memory Packages Summary**

-   **Package loading**: The `library()` function makes a package's functions available by loading it into memory and attaching it to the search path

-   **Development limitations**: `library()` only works with installed packages, making it inefficient for iterative development

-   **Developer alternative**: `devtools::load_all()` accelerates development by loading source packages directly into memory without requiring installation

    -   This is the default for package development, and it is a handy command to iteratively test how code changes and performs as it develops

-   **Technical distinction**: For package developers (unlike script writers), understanding the difference between loading and attaching packages is important

    -   Will be covered later in the book

-   **2025-05-19:** Stopped at package libraries

```{r}
.libPaths()
lapply(.libPaths(), list.dirs, recursive = FALSE, full.names = FALSE)
```

**R Package Libraries Summary**

-   **Terminology clarification**:
    -   A "library" is a directory containing installed packages
    -   Common mistake: calling packages like `dplyr` "libraries" instead of "packages"
    -   Correct usage: `library()` function loads a package
-   **Multiple libraries structure**:
    -   `.libPaths()` shows active library locations
    -   Typical setup includes both user and system libraries:
        -   **User library:** contains add-on/CRAN packages (first in search path)
        -   **System library:** contains base R packages
-   **Platform differences**:
    -   **Windows:** typically has separate user/system libraries by default
    -   **macOS/Linux:** often needs manual setup of user libraries
    -   User libraries typically version-specific (need to reinstall packages after R minor version updates)
-   **Advanced library management**:
    -   Tools like `renv` manage project-specific libraries for reproducibility
    -   Methods to control libraries (from persistent to temporary):
        -   Environment variables (R_LIBS, R_LIBS_USER)
        -   `.libPaths()` function
        -   `withr::with_libpaths()` for temporary changes
        -   Function-specific arguments
-   **Critical note for developers**: Never use `library()` inside a package (packages use different dependency mechanisms than scripts)
    -   We have already seen an example of this with `regexcite` where using the `stringr` package as a dependency was executed using `usethis::use_package()`
-   **2025-05-19:** End of Chapter 3
    -   Claude summaries are excellent, and this book is exceptional
    -   Would be interested to see if there are any other books that Hadley is releasing any time soon that I could go through
    -   Every book this guy produces is golden

# Chapter 4: Fundamental Development Workflows

**Before Creating a Package**

-   Consider two types of payoff: the product itself (improved functionality) and the process (greater R mastery)
-   Survey the existing landscape to understand similar packages
-   It's valid to create your own implementation even if similar packages exist:
    -   For learning purposes
    -   If existing packages have unsuitable user interfaces or defaults
-   Study domain-specific design patterns if your work falls into a well-defined area
    -   This is highly relevant and something I already am aware of
        -   For my desired `ggtcga` package, it is commonly accepted that the input dataset is a `summarizedExperiment` object and my output is going to be DEA analysis volcano plots, feature plots, and survival plots
        -   These are the norms in the field and I intend to embrace these for my first package‚ÄîI am sure there will be a lot of mistakes along the way, but experts get that way by building things
        -   I also intend to use the same conventions embraced by packages that extend `ggplot2`, such as `ggstatsplot`, and `Seurat`, such as `SCPubr`
            -   In a way, Seurat itself started off as a wrapper around `SingleCellExperiment` and `scater` that replicated their functionality and extended it by adding community detection algorithms for clustering

**Naming Your Package**

-   Formal requirements:
    -   Only letters, numbers, and periods allowed
    -   Must start with a letter
    -   Cannot end with a period
-   Best practices:
    -   Choose a unique, Google-able name
    -   Avoid names already on CRAN or Bioconductor
    -   Use all lowercase letters for memorability
        -   `ggtcga`
    -   Prioritize pronounceable names
    -   Consider modifications of words that evoke the problem
    -   Abbreviations can work well
    -   Adding an extra "R" is a common pattern
    -   Be mindful of trademark issues
-   Use the `available` package to evaluate potential names

**Creating the Package**

-   Two methods (which are actually the same):
    -   Use `usethis::create_package()`
    -   Or in RStudio: `File > New Project > New Directory > R Package`
-   Creates minimal working package with:
    -   `R/` directory
    -   Basic `DESCRIPTION` file
        -   Description of the package and its functionality
    -   Basic `NAMESPACE` file
        -   Contains the names of the functions that the package offers
    -   RStudio project file (`.Rproj`)
    -   Basic `.Rbuildignore` and `.gitignore` files
-   Avoid using `package.skeleton()` which creates problematic packages
    -   Old package development framework that is no longer relevant

**Package Location**

-   Keep source packages separate from installed packages
-   Common practice is to have a designated directory in your home folder
-   Possible organization schemes:
    -   By development role
    -   By GitHub organization
    -   By development stage
    -   By publication or data product
-   Choose a consistent organization system that works for your needs
    -   The key thing to remember is that source and installed packages should be independent from one another
    -   In my case, it is very likely that I will have them in directories inside my OneDrive, and I will develop them there
-   **2025-05-20:** Start of chapter 4 and finished section 4.1
    -   Will start on 4.2 next
    -   The combination of Claude for summaries and my note-taking after is exceptional

**Summary: RStudio Projects for R Package Development**

-   **Core Concept**: RStudio Projects work synergistically with `devtools` to create an optimal R development environment

-   A Project (capital P) is a directory with RStudio infrastructure that facilitates work on projects like R packages, data analyses, or Shiny apps

-   **Key Benefits**:

    -   **Isolation & Organization**: Each project is self-contained with no cross-contamination between different projects, even when multiple are open simultaneously

    -   **Streamlined Workflow**: Easy project launching with proper file browser and working directory setup

    -   **Enhanced Navigation**: Built-in tools like F2 (jump to function definitions) and Ctrl + . (function/file lookup)

    -   **Development Integration**: Keyboard shortcuts and clickable interfaces for common package tasks (documentation, testing, checking)

    -   **Command Access**: Command Palette (Ctrl/Cmd + Shift + P) for quick access to all IDE commands

    -   **Version Control:** built-in support with RStudio projects in the IDE that facilitates the entire process

-   **Setup Options**:

    -   **New packages**: `create_package()` automatically creates RStudio Projects

    -   **Existing packages**: File \> New Project \> Existing Directory, `create_package()` on existing directory, or `usethis::use_rstudio()`

        -   In the documentation, it is recommended to use either `create_project()` or `create_package()`

            -   Actually, `create_project()`, like `use_git()` and `use_github()`, is more useful across the board as I can use that for my analyses as well as package development

        -   Both would work better than `create_rstudio()` because they do the same thing and are more explicit about the purpose of the RStudio project

    -   **General projects**: `usethis::create_project()` for non-package projects

-   **My Experience**: I've already adopted RStudio Projects for analyses and particularly value how they maintain consistency with version control - a major workflow improvement that aligns with the isolation and organization benefits described

-   The combination of `devtools` + RStudio Projects creates a comprehensive development ecosystem that streamlines R package development from creation to deployment

-   **2025-05-22:** Stopped at section 4.2.3

    -   Brief work today as I am rather busy with preparation for Fadi's presentation

**RStudio Project Structure**

-   **Core Component**: Every RStudio Project contains a `.Rproj` file (typically named after the directory, e.g., `foo.Rproj` for directory "foo"). This is a simple text file that stores project settings and can be configured through Tools \> Project Options rather than manual editing.

-   **Best Practice**: Align naming - if your directory is "foo", the project file should be `foo.Rproj`, and if it's an R package, the package name should also be "foo". Avoid nesting packages in subdirectories to minimize friction with tools.

**Project Management**

-   **Launching Projects**: - Double-click the `.Rproj` file in your file explorer - Use File \> Open Project within RStudio - Use productivity apps/launchers for streamlined access - Multiple projects can (and should) be open simultaneously

-   **Project Alignment**: The `usethis` package assumes these three elements typically coincide: - Current RStudio Project - Active usethis project\

    -   Current working directory - Use `proj_sitrep()` to diagnose when things get out of sync

**Working Directory Philosophy**

-   **Core Principle**: Keep the top-level package directory as your working directory throughout development. Avoid constantly changing directories with `setwd()`.

-   **Why This Matters**:

-   **Explicit vs. Implicit Paths**: Write paths that clearly express intent ("read from test directory") rather than assuming current location

-   **Package State Resilience**: Packages exist in different forms during development - explicit paths work across all states

-   **Tool Compatibility**: R CMD build/check/install processes change working directories unpredictably

**Solutions**: Use path helpers like `testthat::test_path()`, `fs::path_package()`, and `rprojroot` for robust path construction.

**Development Workflow with load_all()**

-   **Central Function**: `load_all()` is the cornerstone of the devtools development cycle - it simulates installing and loading your package without actually installing it.

-   **Key Benefits**:

    -   **Rapid iteration**: Quick testing of code changes without full installation

    -   **Namespace accuracy**: Develop under realistic namespace conditions

    -   **Internal function access**: Call your own functions directly without `:::`

    -   **Dependency management**: Use imported functions without `library()` calls

    -   **Compiled code efficiency**: Especially valuable for packages with C/C++ code

-   **Usage**:

    -   **Keyboard shortcut:** Cmd+Shift+L (macOS), Ctrl+Shift+L (Windows/Linux)

    -   **RStudio Build pane**

    -   **Direct function call:** `devtools::load_all()`

-   **Development Cycle**: Edit code ‚Üí `load_all()` ‚Üí test ‚Üí repeat

**Summary: R CMD check and Package Validation**

-   **Purpose & Importance:**

    -   R CMD check is the official validation tool for R packages

    -   Essential for CRAN submission but recommended for all packages to catch common problems early

-   **Recommended Workflow:**

    -   **Use `devtools::check()`** instead of command line R CMD check for better integration

    -   Run from R console: `devtools::check()` - RStudio shortcuts: Ctrl/Cmd + Shift + E - Available in Build menu/pane

-   **Key Philosophy: Check Early & Often**

-   **Common Mistake**: Working too long before first check, then discovering many problems

-   **Best Practice**: Check multiple times per day when actively developing

-   **Rationale**: Earlier problem detection = easier fixes

-   **What check() Does Internally**

    1.  Updates documentation via `devtools::document()`

    2.  Bundles the package for clean slate checking

    3.  Sets `NOT_CRAN` environment variable to "true"

    4.  Runs full R CMD check process

-   **Check Results Types**

    1.  **ERRORs**: Severe problems - fix regardless of CRAN plans

    2.  **WARNINGs**: Likely problems - must fix for CRAN submission

    3.  **NOTEs**: Mild issues - eliminate all for CRAN; evaluate individually if not submitting

-   **Simple Workflow**

    1.  Run `devtools::check()`

    2.  Fix first problem

    3.  Repeat until clean

-   **Direct Usage:** For advanced users: Run `R CMD check` directly in terminal on package bundles, but `devtools::check()` is preferred for development workflow integration.

-   **2025-06-05:** Finished chapter 4. A little sloppy tired because I am fasting. All done though.

# Chapter 5: The Package `Within`

Here's a brief summary of the key points covered:

-   **Main goal**: Transform a data analysis script into reusable R package components

-   **Example scenario**: Script that processes swimming survey data (location + temperature) with mixed US/UK terminology and temperature units

-   **Original script issues**: Repetitive code, copy/paste patterns, mixed code and data, inefficient practices

-   **Refactoring improvements**:

    -   Used tidyverse packages (readr, dplyr)
    -   Created lookup table for location/language mapping
        -   This was a very nice way of doing refactorization that I did not see before
            -   However, a better way to do this is using `dplyr::recode()`
    -   Extracted helper functions (f_to_c, timestamp, outfile_path)
    -   Separated data from logic
        -   The idea here is to code functions first and then use them to process the data
        -   This separation makes the code modular and reusable, and this coding style then facilitates a transition to package creation
            -   In future analyses I do, I will start embracing this style of coding a bit more where possible
                -   Might be worthwhile to create a package on top of Seurat that adds all of the Seurat options that I have been wanting
                    -   Literally building a wrapper on top of the wrapper

-   **Key lesson**: Refactoring scripts to isolate reusable data and functions makes it easier to identify components that could become a package

-   **End result**: Cleaner, more maintainable code that reveals the "package that lurks within" the original script

-   **2025-06-06:** Stopped at the start of section 5.3

**Converting Scripts to Packages - Key Points**

**The Process (Charlie ‚Üí Delta ‚Üí Echo ‚Üí Foxtrot ‚Üí Golf)**

-   **Charlie**: Start by moving reusable code and data into separate helper files
-   **Delta**: First package attempt fails - functions not exported, CSV files not accessible, dependencies not declared
-   **Echo**: Working package with proper `@export` tags, namespace-qualified function calls (`dplyr::`), and DESCRIPTION dependencies
-   **Foxtrot**: Fix build time vs. run time issues - move `Sys.time()` calls inside functions, not as top-level assignments
-   **Golf**: Handle side effects properly using `withr` package to make temporary state changes without affecting user's session

**Key Lessons: Script vs. Package**

-   **Don't convert everything**: Extract recurring operations that appear across multiple projects, not entire scripts
-   **Scripts still exist**: You'll still have R scripts, R Markdown reports, and Shiny apps - packages just make them more concise and maintainable
-   **Identify patterns**: Look for code you copy/paste between projects and operations you do repeatedly

**Key Lessons: Finding the Package Within**

-   **Start messy**: Begin with scattered, idiosyncratic scripts across different projects
-   **Notice repetition**: Identify needs that come up over and over again
-   **Refactor gradually**: Move from copy/paste to helper functions to separate files
-   **Extract when ready**: Once you have helper functions in their own file, you're ready for a package

**Key Lessons: Package Code is Different**

-   **Dependencies**: Use DESCRIPTION file and namespace-qualified calls (`pkg::function()`), not `library(pkg)` calls
-   **Data storage**: Use package-specific methods for persistent data/files, not just dumping files in the package
-   **Function visibility**: Be explicit about exports with `@export` - functions are internal by default
-   **Timing discipline**: Ensure code runs at intended time (build vs. run time) and avoid unintended side effects
-   **State management**: Use `withr` package for temporary changes to avoid affecting user's R session

**2025-06-10: End of chapter 5**

# Chapter 6: R Code

-   **All R code goes in R/ directory** as .R files

-   **Avoid extremes**: don't put all functions in one file or each function separately

-   **Group related functions**: main function with helpers or function families

-   **Use meaningful file names** that convey which functions are inside

-   **Create R/utils.R** for small utilities used across multiple functions

-   **Use `devtools::load_all()`** for fast feedback instead of sourcing files

-   **Follow tidyverse style guide** and use *styler package* to enforce it automatically

-   **RStudio shortcuts**: *Ctrl + .* for Go to File/Function, *F2* to jump to function definition

-   **Development workflow**: `load_all()`, `test()`, and `check()` for package development

**2025-06-17: Stopped at the start of section 6.4**

**When Code Executes:**

-   Package code runs at build time (when the package is created), not when users load it - this means objects are cached from the build environment, which can cause problems if build and user environments differ

**Write Functions, Not Top-Level Code:**

-   Any R code outside of functions is suspicious - instead of creating objects at the package level, wrap that logic in functions that execute at runtime when users actually call them

**Don't Modify the Global Environment:**

-   Avoid functions like `library()`, `require()`, `source()`, `setwd()`, `options()`, and `par()` that change global settings - if you must use them, clean up afterwards using tools like the withr package

**Don't Assume User Environment:**

-   Your functions will run on different systems with different locales, working directories, and settings than yours - write defensive code that doesn't rely on specific environmental assumptions

**Real-World Examples:**

-   File paths from `system.file()` that work during build but fail on user machines, color display objects cached from headless build servers, and function aliases that get stuck with old buggy versions all illustrate these principles

The core principle is that package code should create reusable functions that work reliably across different environments, not execute specific logic that gets baked in at build time.

**2025-06-17: Stopped at the start of section 6.5.1**

**Managing State**

-   Use **withr package** or **`on.exit()`** to restore environment changes when functions exit

-   **withr helpers:** `with_*()` for code snippets, `local_*()` for function-duration changes

-   Always use **add = TRUE** with `on.exit()`

**Side Effects**

-   **Isolate** plotting/output into dedicated functions

-   Use **`.onLoad()`/`.onAttach()`** for package initialization

-   **Prefix package options** with package name

**Development Workflow**

-   **Iterate frequently:** Edit ‚Üí `document()` ‚Üí `load_all()` ‚Üí `test()` ‚Üí `check()`

-   **Run checks often** - don't wait until end

**CRAN Requirements**

-   **ASCII characters only** in .R files

-   Use **Unicode escapes** like "\u2022" for special characters

-   Check for hidden non-ASCII with **tools::showNonASCII()**

**2025-07-30:** Chapter 6 is complete and starting chapter 7 next time

-   I am thinking I should start package development soon because I feel like I am getting bogged down in useless details instead of learning the actual process by doing

-   I just want to finish the next chapter about working with data inside the R package before starting because I will need test data and the sample development workflow they showed me in chapter 1 did not use any external data

-   This chapter however has been very cryptic and the advice mostly pertains to shit that I am not going to be dealing with in the early stages of development

# Chapter 7: Data

**Data in R Packages**

**Storage Locations**

-   **`data/`**: User-accessible data as `.rda` files (most common)
-   **`R/sysdata.rda`**: Internal data for package functions
-   **`inst/extdata/`**: Raw files (CSV, Excel, etc.)
-   **Environments**: Dynamic session-specific data
-   **Sanctioned locations**: Persistent cross-session data

**Main Workflow with `data/`**

-   Use `usethis::use_data(my_data)` to automatically:
    -   Save as `data/my_data.rda`
    -   Enable lazy loading via `LazyData: true` in DESCRIPTION
    -   Make data available as `pkg::my_data` or `my_data` after `library(pkg)`
-   Lazy loading = data only loads when accessed, saving memory
-   Avoid unnecessary `data()` calls - data is immediately available

**Data Preparation**

-   Keep data-generating code in `data-raw/` (use `usethis::use_data_raw()`)
-   Scripts in `data-raw/` should end with `usethis::use_data()` call to then add the data being generated as `rda` files under the `data/` directory
-   Enables reproducible data reconstruction

**Documentation (Required)**

-   Document in `R/data.R` using roxygen2
-   **Key tags:** `@format` (structure/variables), `@source` (origin)
-   Never use `@export` for datasets

**Technical Notes**

-   **Size**: \<1MB for CRAN
-   **Compression**: Default "bzip2", experiment with "gzip"/"xz"
-   **Encoding**: UTF-8 for non-ASCII (generates harmless CRAN notes)
-   **Best practice**: One object per `.rda` file with matching names

**Key Benefit**

The `devtools`/`usethis` ecosystem reduces complex package data workflows to simple function calls, making development structured and maintainable

**2025-07-31:** Stopped at section 7.2, and this chapter is very good imo with lots of important points that are vital for my package development

**Internal Data (R/sysdata.rda)**

**Purpose & Storage**

-   Use `R/sysdata.rda` for internal data that package functions need but users shouldn't access

-   For large/complex objects too big to define directly in R code

**Creation & Management:**

-   Create with `usethis::use_data(internal = TRUE)` - puts all internal objects in one file
-   Store generation code in `data-raw/`, not `R/`
-   Available to package functions, tests, and after `devtools::load_all()`

**Key Differences from External Data:**

-   No documentation needed (not exported)
-   Always lazy-loaded regardless of `LazyData` field
-   All objects in one file vs. separate files for external data

**Raw Data Files (inst/extdata/)**

**Purpose & Location:**

-   Store original/raw files in `inst/extdata/` for examples and demos
-   Files move to `extdata/` when package is installed
-   Main use: when package functionality acts on external files

**Common Use Cases:**

-   File parsing packages (readr, readxl, xml2, archive)
-   Data packages providing multiple formats (palmerpenguins, gapminder with CSV versions)

**Benefits:**

-   Useful for documentation and tests
-   Helps teaching with familiar datasets
-   Plain text versions track data changes over time

**2025-08-04:** stopped at section 7.3.1

-   I am starting to think it could be a very good idea to start creating a very small package of helpful utilities and functions that I have to iterate through often for scRNA-Seq analysis

    -   What I have in mind are custom versions of `SCPubr` functions that include my most used settings, a simpler `ggsave` call that uses pdf by default and uses large width and height parameters out of the box, and a GSEA barplot figure that is way better than the shit `clusterprofiler` spits out

    -   Will start working on that some time towards the end of this week to start getting some real hands-on experience with package development

        -   Maybe, this shit works, and I finally have something new that is enhancing my workflows

            -   Imagine having helper scripts that contain my preferred presets and wrapping these into packages of my own making

                -   Now that would be fun and interesting and would add a lot to my computational skillset

**Remainder of Chapter 7**

-   `inst/` directory contains supporting stuff that does not go into `R/`, `data/`, or `vignettes/`

-   Section 7.3 is frankly too technical and thus a waste of time‚ÄîI have gone through it briefly and the details are just too boring at this point

-   Gone through the rest of the chapter and frankly all of this stuff is far too technical my g

-   Chapter 7 is done

    -   I tried summarizing the chapter using chatGPT, and it seems to do a better job on summaries than claude

        -   When the time comes for my package development work, I will create a more concise version of these notes that only included the most key points

# Chapter 8: Other Components

**üì¶ Beginner-Friendly Summary of Miscellaneous Package Components**

Chapter 8 of *R Packages* introduces **less common package directories**. Most are optional for beginners, but here‚Äôs what matters:

**1Ô∏è‚É£ `src/`: Source**

-   Holds **compiled code** (C or C++).
-   Boosts performance or uses external libraries.
-   **Ignore for now** unless you move into C++ or heavy performance work.

**2Ô∏è‚É£ `inst/`: Install**

-   Holds **extra files you want included** in the **installed** package.

    -   Installed is the key word here.

-   **All files move to the root** of the package when installed.

-   Common uses:

    -   `inst/extdata/` ‚Üí raw example files (CSV, FASTQ, etc.)
    -   `inst/CITATION` ‚Üí how to cite the package
    -   `inst/rmarkdown/templates/` ‚Üí custom R Markdown templates
    -   RStudio add-ins or Shiny examples

-   ‚ö° **Think of it as a ‚Äúmisc storage‚Äù folder for user-accessible files.**

**3Ô∏è‚É£ `tools/`**

-   Holds **auxiliary build or config files** (often with `configure`).
-   **Advanced only**; safe to ignore for now.

**4Ô∏è‚É£ `demo/`**

-   For **legacy demos**.
-   Modern practice ‚Üí use **vignettes** or **README examples** instead.

**5Ô∏è‚É£ `exec/`**

-   For **executable scripts**, automatically flagged as executable.
-   Rarely used; modern practice often prefers `inst/`.

**6Ô∏è‚É£ `po/`**

-   For **translations (internationalization)**.
-   Advanced topic; **ignore for now**.

**üí° Beginner Takeaways**

-   **Focus on `inst/`** for any extra files like raw data or templates.
-   **Ignore `src/`, `tools/`, `demo/`, `exec/`, and `po/`** until your package grows.
-   **Prefer vignettes and README over demos**, and **`inst/extdata`** for raw example files.

**2025-08-05:** Chapter 8 is over, and I am starting to aggressively move through the book and ignore bits and pieces that I think are useless

-   Whilst the explanation of the book is to-the-point, there is a lot of extra stuff that is not necessary for a beginner

    -   That's why I am skipping that shit and moving forward

# Chapter 9: DESCRIPTION

üì¶ **Key Points About DESCRIPTION**

-   **Purpose**:

    -   Defines your package as an R package (any folder with a DESCRIPTION is a package).
    -   Stores **metadata**: name, version, authors, dependencies, URLs, and license.

-   **Essential Fields**:

    1.  **Package** ‚Äì Short, unique name of your package.

    2.  **Title** ‚Äì One-line, title case, no period; describes what the package does.

    3.  **Description** ‚Äì One-paragraph explanation of the package; indent multi-line entries.

    4.  **Version** ‚Äì Use `0.0.0.9000` for development versions.

    5.  **Authors\@R** ‚Äì Use `person()` function to list authors/maintainers with roles:

        -   `cre` = maintainer (must have email)
        -   `aut` = main authors
        -   `ctb` = contributors

    6.  **License** ‚Äì Mandatory, use a standard form (`use_mit_license()`, `use_gpl3_license()`).

    7.  **URL / BugReports** ‚Äì Link to website, repo, and issue tracker (auto-added by `usethis::use_github()`).

-   **Formatting Tips**:

    -   Use **single quotes** around R packages or software names.
    -   Avoid ‚ÄúA package for ‚Ä¶‚Äù in Title or Description.
    -   Description lines ‚â§80 characters; indent subsequent lines by 4 spaces.
    -   **CRAN checks** pay special attention to Title, Description, and License.

-   **Tools to Help**:

    -   `usethis::create_package()` ‚Üí Generates minimal DESCRIPTION.
    -   `desc` package ‚Üí Edit DESCRIPTION programmatically.
    -   `usethis::use_github()` ‚Üí Adds URL and BugReports automatically.

**2025-08-06:** Stopped at section 9.6 because it's important and needs my full attention‚ÄîI also got a bit bored as I usually do

-   Continuing with the pattern of dashing through chapters, this one is going by quickly even though it is very useful

    -   Easier to do work quickly on two cups of coffee

        -   Who would have thought?!

**üì¶ `DESCRIPTION` File: Imports, Suggests & Other Fields**

**‚úÖ Core Dependency Fields**

-   **`Imports:`**

    -   Required **at runtime**.

    -   Automatically installed with your package.

    -   Example:

        ``` r
        Imports:
            dplyr,
            tidyr
        ```

    -   You will note here that package version is not specified, so I can create my own packages and use them with whatever version of these packages that I have

        -   There is also the option to specify a minimum version of the package, so that's there to for when I am officially developing packages for release to the public

-   **`Suggests:`**

    -   Optional packages for **development**, testing, or extended features.

    -   Not required for basic functionality.

    -   Example:

        ``` r
        Suggests:
            ggplot2,
            testthat
        ```

-   Use `usethis::use_package("pkg")` to add packages cleanly.

    -   Defaults to `Imports`.
    -   Use `"Suggests"` explicitly if needed in the `type` argument of `use_package()`.

üî¢ **Minimum Versions**

-   Specify with parentheses: `dplyr (>= 1.0.0)`
-   Avoid `==` (exact match) ‚Äî too rigid.
-   Use `usethis::use_package("pkg", min_version = TRUE)` to lock to your current version if needed.
-   Be **cautious**: Setting higher version requirements may cause install issues for others.

‚ùå **Other Dependency Fields (Use Rarely)**

-   **`Depends:`**

    -   Avoid unless setting R version: `Depends: R (>= 4.0.0)`
    -   `Imports` is preferred.

-   **`LinkingTo:`**

    -   For packages using C/C++ from other packages.

-   **`Enhances:`**

    -   Used to signal your package adds features to another. Rarely used.

‚ö†Ô∏è **R Version Gotcha**

-   `.rds` files saved in R ‚â• 3.6.0 use serialization **version 3**, unreadable by R \< 3.5.0.
-   Can **silently bump** R version in DESCRIPTION.
-   Be deliberate with `.rds` file formats to avoid unexpected version dependencies.

üìÑ **Other Common Fields**

-   **`Version:`**

    -   Tracks the version of your package.

-   **`LazyData:`**

    -   Makes package datasets auto-available without `data()`.

-   **`Encoding:`**

    -   Usually set to `UTF-8`.

-   **`Collate:`**

    -   Controls order of R file loading; used for S4 classes.

-   **`VignetteBuilder:`**

    -   Declares which vignette engine to use (e.g., `knitr`).

-   **`SystemRequirements:`**

    -   Declares external software needed (e.g., `C++17`, `TensorFlow`).
    -   Does not install anything, so further information should be added to README to specify installation instructions

üõ†Ô∏è **Custom Fields**

-   Use `Config/*` prefix for any **custom metadata**.
-   Avoid redefining official field names.
-   Example: `Config/Needs/website`

‚úçÔ∏è **roxygen2 Fields**

-   Generated by `create_package()`:

    -   `Roxygen: list(markdown = TRUE)`
    -   `RoxygenNote: <version>`

-   Related to documentation setup.

**2025-08-07:** Chapter 9 over and continuing the quick move through the book

-   Again, working on two cups of coffee hits different

# Chapter 10: Dependencies ‚Äî Mindset & Background

-   **When to add dependencies:** Framework for deciding if a dependency is worth the risk/reward
-   **Dependency types:** Guidance on choosing between `Imports`, `Suggests`, and `Depends`
-   **Namespaces:** How R's namespace system prevents package conflicts and ensures consistent behavior
-   **Beginner-friendly:** Can skip initially but important for more complex packages

**2025-08-13:** Stopped at the beginning of chapter 10.1

-   Very little progress today as I am operating on very little sleep and wanted to simply start the chapter without pushing too far in it

**Low-cost dependencies:**

-   Base R packages (`base`, `utils`, `stats`) and recommended packages
-   Packages with few upstream dependencies (like `rlang`)
-   Already-installed popular packages (like `ggplot2`)

**High-cost dependencies:**

-   Non-CRAN packages requiring special setup

-   Packages with many recursive dependencies (\~250+)

-   Large/slow-compiling packages (some take 100+ seconds vs 5 seconds)

-   Packages requiring system dependencies (Java, external libraries)

**Key factors:** Installation burden, maintenance quality, and functionality value all matter more than just counting total number of dependencies.

**2025-08-14:** stopped at section 10.1.2

-   Progress is a bit slow this week due to turbulanecs

**Dependency Philosophy**

-   **Take a holistic approach** - Consider your audience (package authors need lean packages, data scientists can handle more dependencies)
-   **Balance trade-offs** - Dependencies give you features/bug fixes but cost installation time, disk space, and maintenance burden
-   **Be quantitative** - Use tools like `pak::pkg_deps_tree()` to analyze dependency weight rather than just minimizing count

**Tidyverse-Specific Guidelines**

-   **Never depend on meta-packages** - Don't put `tidyverse` or `devtools` in Imports; depend on specific packages instead
    -   I did see that as a warning when I was developing my own package
-   **"Free" dependencies** - `rlang`, `cli`, `glue`, `withr`, `lifecycle` are considered lightweight and acceptable
-   **Easy setup** - Use `usethis::use_tidy_dependencies()` to add these core tidyverse dependencies to your DESCRIPTION
-   **CRAN limit** - Avoid 20+ non-default packages in Imports (triggers a NOTE)
    -   Try to handle all notes in your package before submission and in general

**Imports vs Suggests**

-   **Imports** - Required packages that auto-install with your package
-   **Suggests** - Optional packages for tests, vignettes, or rare functions; users must install separately
    -   Early stages of package development do not usually require Suggests at all, so put everything you need in Imports, especially since my audience is other bioinformaticians rather than package developers

**Namespaces (10.2.1 Simplified)**

-   **Problem**: Multiple packages can have functions with the same name (e.g., `lubridate::here()` vs `here::here()`)
-   **Solution**: Use `package::function()` syntax to specify exactly which function you want
    -   This is already the default behaviour I am using in all of my package scripting
-   **Key insight**: Package functions are protected from user interference - even if you redefine `var()`, `sd()` still works because it looks in the `stats` namespace first, not your global environment
-   **Bottom line**: Namespaces prevent chaos by ensuring package functions always find their intended dependencies

**2025-08-18: Stopped at section 10.2.2**

-   Brisk progress today as this is becoming more relevant for my own real-life package development with `BadranSeq` and the package I am keen to develop for my brother's analysis

**R Package Namespaces Summary**

**NAMESPACE file**: Defines what your package exports (for users) and imports (from other packages). Usually auto-generated by roxygen2.

**Function lookup**:

-   User code searches global environment ‚Üí attached packages (can cause conflicts)

-   Package code uses isolated namespaces (prevents conflicts)

**Loading vs Attaching**:

-   Loading: Makes package available in memory

-   Attaching: Adds to search path (what `library()` does)

**Key rule**: Use `Imports` (not `Depends`) in DESCRIPTION to load packages without cluttering users' search path.

# Chapter 11: Dependencies ‚Äî In Practice

-   **`Imports` in DESCRIPTION** ‚â† importing functions (just ensures packages get installed)

-   **To actually use functions**: Need NAMESPACE directives (`import()`/`importFrom()`) OR `::` notation

-   **Rule**: All packages in NAMESPACE must be in DESCRIPTION, but not vice versa

-   **Common pattern**: Package listed in `Imports` but not in NAMESPACE

    -   I can vouch for this because almost all of my packages in `Imports` under DESCRIPTION are not in the NAMESPACE file and are referred to in my package source code under `R/` using `::`

-   Summary here: use `::` to refer to external functions in your package source code, import specific functions minimally using `importFrom`, and almost never import an entire external package's namespace

    -   The upside of this import fuckery is that you can use external functions without referencing the package they came from, which is fantastically retarded because you can't then tell your own functions from the external package's functions

**Default approach: Use `package::function()` syntax**

-   Call external functions like `aaapkg::aaa_fun()` in your code
-   Makes it clear which functions are external vs. your own
-   Avoids name conflicts

**When to import functions instead:**

-   Operators (like `%>%` pipe) - you can't use `::` with these
-   Functions you use constantly - reduces typing and improves readability
-   Functions called millions of times in loops - minor performance benefit

**How to import:**

-   Single function: `#' @importFrom aaapkg aaa_fun` in roxygen comments
-   Whole package: `#' @import aaapkg` (rarely recommended)
-   Run `devtools::document()` to update your NAMESPACE file

**Managing unused imports:**

If R complains about an unused import, add a reference like:

``` r
ignore_unused_imports <- function() {
  aaapkg::aaa_fun  # Just reference it, don't call it
}
```

**The main tradeoff:** importing makes code cleaner but obscures where functions come from. The `::` syntax is more explicit but verbose.

-   **2025-08-25:** Stopped at section 11.4.2

    -   Take-home message is use `package::function()` syntax unless you absolutely need a package or a function to be imported

        -   This will rarely be the case so stick to this syntax, especially with the existence of LLMs that can handle the verbosity

**Book coverage:** The R Packages book explains that while you *can* use shortcuts like `import` or `library()` calls to avoid `package::function()` syntax, these create inconsistencies and potential issues.

**Your core principle:** Always use `package::function()` syntax for external functions everywhere - test code, examples, vignettes, main code. No exceptions.

**Why this matters now:**

-   LLMs make this convention trivial to follow - just ask them to annotate all external functions in your code
-   Work function-by-function with LLMs to avoid hallucination and maintain clean code
-   The book covers shortcuts because developers used to be lazy about explicit syntax, but LLM assistance removes that excuse

**Dependency reality check:**

-   `Imports` = guaranteed to be available
-   `Suggests` = probably not installed (most users skip these during installation)
-   `library()` calls are possible but you prefer explicit `package::function()` for maximum clarity

**Your stance:** Ignore the book's shortcuts and embrace explicit syntax everywhere, leveraging LLMs to make it effortless and consistent.

-   **2025-08-29:** Stopped at section 11.5.1

    -   Same points as the last chapter but expanded

        -   All in all a very boring chapter to work on, and these chapters do not seem to add a lot more on top of the introductory chapter for the same material

            -   `Imports` lists all of the packages that your package needs

            -   `Suggests` lists optional packages that are typically ignored

            -   `Depends` is no longer used and only relevant for R version

        -   That's the gist of this boredom

**Chapter Summary: Package Dependencies and Exports**

-   **Dependencies in Depends**: When a package is listed in `Depends`, it gets attached automatically when your package loads, allowing direct function calls without namespace syntax in examples and vignettes, though `pkg::function()` syntax is still recommended in package code

-   **Nonstandard Dependencies**: Use `Remotes` field for development versions from GitHub or other non-CRAN sources (temporary only, don't submit to CRAN), and `Config/Needs/*` fields for packages needed only for specialized tasks like website building or testing

-   **Export Strategy**: Export only functions intended for public use since exported functions require documentation and interface stability - it's better to export too little than too much, and utility functions should generally remain internal

-   **Re-exporting Functions**: Make functions from dependency packages available to your users by listing the source package in `Imports` and using `@export` and `@importFrom` roxygen tags together

-   **S3 Methods and Namespace**: Export S3 generics you own with `@export`, use `@exportS3Method pkg::generic` for methods of generics from other packages (especially suggested dependencies), and regular `@export` works for methods of base R generics

-   The key principle throughout is maintaining clean separation between public API and internal implementation while properly managing dependencies across different usage contexts

<!-- -->

-   **2025-09-15:** End of chapter 11, which was a waste of time and energy‚Äîit was far too specific to be useful to a beginner or intermediate package developer

# Chapter 12: Licensing

-   **Two main license types**: Permissive licenses (like MIT) allow free use with minimal restrictions, while copyleft licenses (like GPL) require derivatives to also be open source

-   **R community preference**: Unlike other programming languages, \~70% of CRAN packages use copyleft licenses (GPL) compared to only \~20% using permissive licenses

-   **Quick license selection guide**: Use MIT for minimal restrictions, GPL for ensuring derivatives stay open source, CC0 for data packages, or proprietary for closed-source packages

-   **Key licensing files**: DESCRIPTION contains the license field, LICENSE file holds template details or full non-standard license text, and LICENSE.md contains the full license text (ignored by CRAN)

-   **Relicensing challenges**: Changing licenses after publication requires permission from all contributors who hold copyright, making it important to choose carefully from the start

-   **Special considerations**: Data-focused packages should use Creative Commons licenses (CC0 or CC-BY) rather than code-focused licenses like MIT or GPL

-   **2025-09-17:** Stopped at section 12.3

    -   Going through this rapidly and enjoying the read

    -   Claude is doing a very good job of summarizing lots of information into a few bullet points

**Code Contributions and Bundling in R Packages**

-   **Contributor rights**: When someone contributes code via pull request, they retain copyright but implicitly agree to your package license; changing licenses later requires permission from all contributors

-   **License compatibility rules**: You can add restrictions when bundling code but never remove them - MIT code can go into GPL packages, but GPL code cannot go into MIT packages

-   **Stack Overflow caution**: Code from Stack Overflow uses CC BY-SA license which is only compatible with GPLv3, requiring extra care when incorporating into open source packages

-   **Bundling requirements**: When including external code, preserve all original copyright statements, use clear file organization, and add copyright holders to Authors\@R with `role = "cph"`

-   **CRAN compliance**: Packages with mixed licenses need a `LICENSE.note` file describing the overall license and specific licenses of each component

-   **Package dependencies**: Simply importing/suggesting other R packages doesn't create licensing constraints - your package license doesn't need to match the licenses of packages you call via their exported functions

-   **2025-09-21:** End of chapter 12

    -   Useful information on licensing that is not very relevant in the early stages of development

    -   Documentation and testing are far more important topics that I will be tackling next

    -   Claude summaries are very good here, and the bullet points above capture the essence of the chapter

# Chapter 13: Testing Basics

-   I have been waiting for this chapter for quite a bit

    -   This section along with the documentation section are two of the most important pieces I need to enhance my own package development

-   **Why Formal Testing is Worth the Trouble**

    -   **The Problem with Informal Testing:** Current workflow relies on ad hoc console testing, but you forget these tests when returning to code months later, making it easy to break previously working functionality.

-   **Four Key Benefits of Automated Testing**

    -   **Fewer bugs** - Explicit behavior descriptions and adversarial testing mindset catch edge cases and prevent regressions

    -   **Better code structure** - Testing pressure naturally leads to well-factored, modular functions that work in isolation

    -   **Clear call to action** - Converting bugs to failing tests first makes your goal concrete: make the test pass

    -   **Robust code** - Comprehensive test coverage gives confidence to make major changes without accidentally breaking functionality

**The core insight:** you already test your code, but automating those tests pays dividends by systematizing what you're already doing informally.

**2025-10-09:** It has been such a long time, and we stopped at section 13.2

-   I am now back with this, and we are finally on to testing, one of the most important parts of effective package development

**Introduction to testthat for R Package Testing**

-   **Functional design**: testthat is built for R's functional programming style rather than object-oriented testing approaches used in other languages

-   **Edition system**: testthat 3e (third edition) requires explicit opt-in, allowing improvements without breaking the \~5,000 packages that depend on it

-   **Recommendation**: Use testthat 3e for all new packages and actively maintained existing packages

**2025-10-10:** Very short section that took me less than 5 minutes to read

-   Starting slow here to build consistency over the following weeks as this becomes my full-time focus

**testthat Test Mechanics & Workflow Notes**

**Initial Setup**

-   Run `usethis::use_testthat(3)` once per package
-   Creates `tests/testthat/` directory and adds `testthat` to DESCRIPTION
-   Generates `tests/testthat.R` file - **never edit this file**
-   Safe to run on existing packages to upgrade to testthat 3e

**File Organization**

-   Match test files to R/ files: `R/foofy.R` ‚Üí `tests/testthat/test-foofy.R`
-   Test files must be in `tests/testthat/` and start with "test"
-   Use `usethis::use_r()` and `usethis::use_test()` to create/toggle between files

**Test Structure**

-   Each test file contains one or more `test_that()` tests
-   Each test has a description and one or more expectations
-   Basic form: `test_that("description", { expect_equal(actual, expected) })`

**Running Tests - Three Scales**

**Micro-iteration** (individual tests):

-   Use `devtools::load_all()` then run expectations interactively
-   Perfect for rapid function development and refinement

**Mezzo-iteration (single test file):**

-   `testthat::test_file("tests/testthat/test-foofy.R")`
-   RStudio: "Run Tests" button or `devtools::test_active_file()` (Ctrl/Cmd + T)

**Macro-iteration (entire test suite):**

-   `devtools::test()` (Ctrl/Cmd + Shift + T) for all tests
-   `devtools::check()` (Ctrl/Cmd + Shift + E) for full R CMD check

**Key Workflow Tips**

-   File pairs work both ways - `use_test()` from R file, `use_r()` from test file
    -   This is exceptionally handy because you can call the testing function from the code file to open the associated test file and vice versa, which is a very cool hack
-   RStudio shortcuts infer target files from active file
-   Iterate until all tests pass before moving to next development phase

**2025-10-13:** Stopped at 13.4

-   Very informative section that was easy to read and did not take much time to go through

-   Notes above are exceptional and to the point

    -   When this book is done, I will take this file and ask Claude or ChatGPT to re-structure it for more clarity

**Test File Structure**

-   Test files live in `tests/testthat/` and must start with "test"
    -   bear in mind that creating tests with `use_test()`, it automatically adds the necessary prefix so it's something to note when creating test files by hand
-   Each file typically contains tests for related functionality (e.g., `test-dup.r` tests `R/dup.r`)

**Test Hierarchy**

-   **Files** contain multiple related tests for specific functions or features
-   **Tests** group expectations using `test_that(desc, code)` to cover single units of functionality
-   **Expectations** are the atomic testing units using `expect_*()` functions to verify specific behaviors

**Best Practices**

-   Write descriptive test names that read naturally (e.g., "basic duplication works")
-   Test typical usage, edge cases, and error conditions
-   Keep tests focused - prefer multiple small tests over fewer large ones
-   Organize tests so failures clearly indicate what's wrong and where to look

**Test Types Illustrated**

-   Basic functionality testing (normal usage scenarios)
-   Edge case testing (boundary conditions like zero duplicates)
-   Error condition testing (malformed input should produce expected errors)

**2025-10-17:** stopped at section 13.5

-   Cool section but again I am not sure how the test files link to the functions they are testing

    -   Is there some linkage syntax I am not aware of or is this all done by filenames?

        -   If by filenames, what happens when I change them?

        -   If by some linkage syntax, what is it?

    -   Will find the answers later in the book

Here's a concise summary of expectations in `testthat`:

**Structure & Basics**

-   All expectations start with `expect_` and compare actual results to expected values
-   They throw errors when actual and expected results don't match
-   Can be run interactively or inside test files

**Key Expectations**

-   `expect_equal()` - checks equality with numeric tolerance; `expect_identical()` requires exact equivalence
-   `expect_error()`, `expect_warning()`, `expect_message()` - test for conditions; use `class` argument for precise matching instead of `regexp`
-   `expect_no_error()` - explicitly checks for absence of errors

**Snapshot Tests**

-   Record expected results in separate human-readable files for comparison
-   Ideal for testing user interface elements like messages and errors
-   Use `expect_snapshot()` with options like `error = TRUE`, `transform`, or `variant`
-   Only function during non-interactive test runs
-   Review changes with `snapshot_review()` or accept with `snapshot_accept()`

**Common Shortcuts**

-   `expect_match()` - matches character vectors against regular expressions
-   `expect_length()` - checks object length
-   `expect_setequal()` - compares sets regardless of order
-   `expect_s3_class()`, `expect_s4_class()`, `expect_type()` - check object classes and types
-   `expect_true()` and `expect_false()` - general catchalls

**2025-10-23:** A lot of things I did not get about snapshot tests, but I do get the gist of it

-   Chapter is over now and we start with chapter 14 next time

# Chapter 14: Designing your test suite

**Testing Best Practices**

**What to Test**

-   External interfaces only (not internal implementation)
-   Each behavior once
-   Complex/fragile code, not trivial code
-   Always test bugs when discovered
-   Consider test-first approach
    -   You develop the test first and then the code that passed that test, effectively defining your success criteria for the code before running any code

**Test Coverage**

-   Use `covr` package to measure coverage
-   High coverage good, but 100% often not worth it
-   Focus on tricky code and bug hotspots
-   Track with `devtools::test_coverage()` or GitHub Actions
    -   GitHub Actions will be covered later in chapter 20

**Principles**

-   Tests should be self-sufficient
-   Optimize for debugging workflow
-   Obvious code \> clever code
-   Testing is harder than main code‚Äîthis is normal
    -   Most of the field does not discuss testing as much as they discuss the development of the main code
        -   This does make sense, but it means that testing is a sleeper skill that has significant potential

**2025-10-24:** Stopped at 14.2.1

-   Liking this chapter thus far
-   I have also resarted my own package development and am now adding some functions here and there that I think would be of value

**Self-sufficient and Self-contained Tests**

**Core Principle**

-   Test files should be almost entirely `test_that()` calls - avoid top-level code outside tests
-   Each test should contain everything needed to set up, execute, and tear down

**Managing Side Effects**

-   R objects auto-cleanup after each `test_that()` exits
-   Landscape changes persist: files, packages, options, environment variables
-   Use `withr` package to automatically restore state after tests
-   Key functions: `withr::local_options()`, `withr::local_package()`, `withr::local_envvar()`, `withr::defer()`

**testthat 3e Defaults**

-   `testthat::local_reproducible_output()` runs implicitly in each test
-   Sets consistent testing environment (no colors, fixed width, etc.)

**2025-10-27:** Stopped at 14.2.3

-   Good progress and some nice advice here

-   Will have to learn the testing myself though when I get into it for my own packages

**Testing Best Practices Summary**

**Plan for Test Failure**

-   Tests are revisited when broken, so write them to be easily understood and troubleshot
-   Make tests self-sufficient: create objects inline and explicitly call dependencies with `::`
-   Avoid relying on ambient objects or scattered setup code

**Repetition is OK**

-   Tolerate duplication in test code‚Äîprioritize obviousness over *don't repeat yourself (DRY) principles*
-   Repeating simple setup in multiple tests is better than shared file-scope variables
-   For complex setup, use test fixtures

**Remove Tension Between Interactive and Automated Testing**

-   Use `devtools::load_all()` when working on tests
-   Avoid `library()` calls in test files‚Äîthey alter search path and create subtle bugs
-   Call functions directly (if imported) or use `pkg::fun()` syntax
    -   I am always a strong proponent of the later
-   Never use `source()` in tests
    -   Never used that much in my daily workflows to begin with and not sure what it does, so won't be a problem for me

**2025-10-28:** Stopped at section 14.3‚Äîcool section and good advice

-   Very happy with my progress here, and I am loving the idea of getting back into this

-   Already made a post about my latest `EnhancedElbowPlot()` function

**Test File Locations - Summary**

**Where to put test-supporting code:**

-   **`R/` directory**: All functions here (exported or not) are automatically available to tests. Use files like `R/test-helpers.R` or `R/utils-testing.R` for test utilities
-   **`tests/testthat.R`**: Standard entry point file - never edit it, never add `library()` calls here
    -   This file is created and executed automatically when checking the entire package and should not be touched by the developer
    -   This is kind of like the NAMESPACE file, which should only be edited by roxygen2 in most instances and is not for the developer to tamper with
        -   Only exception of course is if you are removing a function or object from the namespace that you have already deleted from your code because roxygen2 will not do that automatically
-   **`tests/testthat/helper*.R`**: Files starting with ***"helper"*** execute before all tests. Perfect for custom test functions and setup code with side effects
    -   This is my preferred location for helper functions associated with testing. Putting them under `R/` seems like a very poor idea, and this location is definitely more natural‚Äîthis very sentiment is echoed by the book
        -   However, it is also important to note that one of the top recommendations in this chapter is to make sure the tests are very clear and self-contained, which results in significant verbosity
            -   In testing philosophy, verbosity and the subsequent clarity is more important than elegance, and that's why adding important variables and inputs for testing in the helper tests might not be the best idea even if elegant
-   **Key distinction**: Helpers in `R/` work like regular package code; helpers in `tests/testthat/helper.R` can use testthat functions and make the testing purpose more explicit

**Rule of thumb**: Use `tests/testthat/helper.R` for test-specific utilities that use testthat functions; use `R/` for general utilities that happen to be useful in tests

**2025-10-29:** Stopped at section 14.3.4

-   Claude summaries are on point here as always

**Testthat Setup Files and Test Organization**

**Setup Files**

-   Setup files are any file below `test/testthat/` that begins with ***"setup"***
-   Handled almost exactly like helper files but with two key differences: not executed by `devtools::load_all()` and often contain corresponding teardown code
-   Good for global test setup tailored for non-interactive or remote environments (e.g., turning off messaging or clipboard writing)
-   Should include teardown code using `withr::defer()` with `teardown_env()` to reverse setup after test execution
-   Keep teardown code alongside setup code in `setup.R` to ensure they stay in sync

**Files Ignored by Testthat**

-   Testthat only automatically executes files that are direct children of `tests/testthat/` AND start with ***"helper", "setup",*** **or *"test"***
    -   This is a very important point because it means that these suffixes are how the package realizes what files to run at what point and after which function/command
-   Other files or directories in `tests/testthat/` are fine but won't be automatically executed (except `_snaps` directory for snapshots)

**Storing Test Data**

-   Best location is below `tests/testthat/`, often in a subdirectory like `fixtures/`
-   Use `testthat::test_path()` to build robust filepaths to test data files
-   `test_path()` works correctly in both interactive development (working directory at package top-level) and automated testing (working directory below `tests/`)
    -   Package data, on the other hand, that is used for the testing of main code under `R/` is saved under `data/` as `.rda` files
    -   the scripts needed to create said `rda` objects under `data/` are stored under `data-raw/`

**Writing Files During Testing**

-   Only write files inside the session temp directory (never in `tests/`, current working directory, or user's home directory)
-   Always clean up files after yourself, even in temp directory
-   Use `withr::local_tempfile()` to create self-deleting temporary files with lifetime tied to test execution environment
-   Use `withr::local_tempdir()` when you need more control over file names, creating a self-deleting temporary directory for intentionally-named files
-   High file system discipline eliminates testing bugs and smooths CRAN submissions

**2025-11-03:** End of chapter 14

-   Today's notes were a bit more advanced but they advocate the right etiquette for developing testing suites
    -   The logic here is that testing datasets that should be under the testing directory and any files or folders you create as part of the test should be temporary, should not alter the package structure, and should be removed as soon as is the test is complete
    -   Makes sense and the book advocates very heavy usage of `withr` package for a lot of this advanced functionality when needed
        -   Seems like `withr` is more a developer's than a user's package

# Chapter 15: Advanced Testing Techniques

**Test Fixtures**

**Core concept:** Structured, explicit setup of test prerequisites when self-sufficient tests aren't practical.

**Three Strategies by Cost/Complexity**

-   **Helper functions** - Fiddly but fast object creation
-   **Local functions** - Setup with side effects requiring cleanup (use `withr::defer()`)
-   **Static files** - Expensive/stable objects saved as `.rds` in `fixtures/`

**Key Principles**

-   Always save the code that creates static fixtures
    -   This is the same logic as saving the code that creates the package data under `data/` in `data-raw/`
    -   In this case, the script is right next to the objects that it creates, and the goal here is to keep a record of how these testing objects were created and allow for future iteration to improve the code generating said objects or the objects themselves
-   Helpers belong in `R/` or `tests/testthat/helper.R`
-   Consider memoisation for costly constructors
-   Test helpers often become useful utilities worth exporting

**2025-11-04:** Stopped at 15.2

-   Advanced chapter so does not have much utility for a beginner

    -   Many concepts are still relevant and useful though, so will go through it regardless

**Building Your Own Testing Tools**

**Helper Functions**

-   Create hyper-local helpers inside individual tests for simple repetition reduction
-   Define custom expectations for repeated checking patterns across multiple tests
-   Keep helpers extremely short and simple to avoid introducing bugs

**When to Create Helpers**

-   If testing requires complicated helpers, consider refactoring the function being tested instead
-   Balance reducing repetition against maintaining obvious, readable tests

**Testing Environment**

-   testthat provides `is_testing()` and `testing_package()` for detecting test context
-   Can inline these functions to avoid run-time dependency on `testthat`

**2025-11-05:** Stopped at 15.3

-   Too technical and too advanced, so I spend less than 5 minutes on this section

-   Definitely not a fan of this at all, but going through it as quickly as I can just to be aware of it

**When Testing Gets Hard - Summary**

**Skipping Tests**

-   Use `testthat::skip()` when tests can't run (no internet, missing credentials, wrong platform)
-   Create custom skippers like `skip_if_no_api()` and call within each test, not at file top-level
-   Built-in skippers: `skip_if()`, `skip_if_not_installed()`, `skip_if_offline()`, `skip_on_cran()`, `skip_on_os()`
-   Danger: skips are invisible in CI - regularly verify skip counts to avoid false confidence

**Mocking**

-   Replace unreliable external dependencies with controlled alternatives
-   Avoid unless necessary - adds complexity
-   Key packages: mockery, mockr, httptest, httptest2, webfakes
-   testthat adding `with_mocked_bindings()` and `local_mocked_bindings()`

**Secrets**

-   Design packages to test without live authentication when possible
-   Use secure environment variables for authenticated testing
-   See `httr2`'s "Wrapping APIs" vignette for details

**2025-11-10:** Stopped at section 15.4

-   Finishing up chapter soon but advice is far too advanced for a beginner or intermediate in the domain of package development

**CRAN Testing Considerations**

-   CRAN runs `R CMD check` regularly on all packages - test suites must comply with Repository Policy
-   Use `skip_on_cran()` at start of tests that shouldn't run on CRAN (checks `NOT_CRAN` environment variable)
-   Tests with `skip_on_cran()` still run in development and CI environments like GitHub Actions

**When to Use `skip_on_cran()`**

-   Long-running tests (total suite should be under 1 minute)
-   Tests with variable timing, parallel code, or strict numerical precision requirements
-   Flaky tests that occasionally fail (web APIs, network resources)
-   Tests that access external resources (CRAN policy requires graceful failures for internet resources)
-   Snapshot tests (skip by default on CRAN)

**CRAN Requirements**

-   Only write to session temp directory (`tempdir()`), never user's home directory or clipboard
-   Clean up all created files and processes
-   Close any external software launched during tests
-   Use `expect_equal()` not `expect_identical()` for cross-platform compatibility
-   Zero tolerance for flaky tests - they block dependency updates
    -   Meaning if I use a flaky test and my package is failing, another package that uses my package as a dependency will fail to be published because of my flaky test
        -   There is a knock-on effect if my tests start failing

**Alternative Strategies**

-   Use CI/CD for functionality impossible to test on CRAN
-   Maintain integration tests outside package if needed
    -   This is what the `tidymodels` team is doing for some reason

# Chapter 16: Function Documentation

**Function Documentation with roxygen2**

Write roxygen comments above functions (lines starting with `#'`), then use **Ctrl/Cmd + Shift + D** to generate `.Rd` files.

**Basic roxygen Structure**

``` r
#' Brief title
#' 
#' @param x Description
#' @param y Description
#' @returns What function returns
#' @examples
#' function_name(1, 2)
function_name <- function(x, y) {
  # implementation
}
```

**Quick Tips**

-   **`Ctrl/Cmd + Shift + D`**: Generate/update documentation
    -   Can confirm that it works and is an exceptional shortcut
    -   You will see it in action under the `Build` tab on the right
-   Position cursor in function, use `Code > Insert Roxygen Skeleton` for template
    -   Can also confirm that this helps massively and LLMs can already generate this documentation readily
-   Preview with `?function` after running `devtools::load_all()`
-   Document all exported functions (R CMD check requirement)
-   Use `@noRd` tag for internal functions to skip `.Rd` generation
    -   Or do not add the export tag, but add the documentation still
        -   That way, your function is not exported to the user, but you still have access to it and have documented it

**2025-11-14:** Stopped at section 16.1.2

-   Excellent chapter, and I expect it to be immensely useful

**Roxygen2 Comments, Blocks, and Tags**

-   Comments start with `#'`, all preceding a function form a **block**
-   Blocks contain **tags** (`@tagName tagValue`) that extend until the next tag
-   Text before first tag is the **introduction** (title + description)
-   Each block generates one `.Rd` file in `man/` directory
-   Maintain consistent line length; indent continuation lines for readability
-   Use `Ctrl/Cmd+Shift+/` in RStudio to reflow comments automatically
-   Tag order in source doesn't affect rendered documentation order

**Key Markdown Features**

-   **Backticks** for inline code: `` `function_name()` ``
-   **Square brackets** for auto-linked functions: `[pkg::func()]` or `[func()]`
    -   Trailing parentheses required for proper formatting
    -   No need for additional backticks
-   **Vignette references**: `vignette("topic", package = "pkg")` auto-links in pkgdown sites
-   **Bullet lists** using `*` to improve scanability
    -   Blank line before list is optional
    -   Works in function descriptions, argument docs, and return values

**2025-11-17:** Stopped at section 16.2

-   Small amount today as I have a headache and am bored mostly

-   Good chapter though and many important points on documentation, most of which I am already aware of

**Function Documentation Structure (Title, Description, Details)**

**Title (First Sentence)**

-   Write in sentence case, no ending period
-   Followed by blank line
-   Shows in function indexes
-   Focus on unique aspects, avoid repetition
-   Use descriptive verbs that differ from function name when possible
-   Example:
    -   `mutate()`: Create, modify, and delete columns
        -   This line is literally the title of the `mutate()` function in dplyr verbs

**Description (Next Paragraph)**

-   Summarize function goal, usually one paragraph
-   Try to reword title slightly to give users another perspective
-   For multiple paragraphs, use explicit `@description` tag
-   Can include bullet lists if using `@description` tag
-   Must use `@description` if including any blank lines
-   In summary, always use `@description` as a matter of habit

**Details (Everything After Description)**

-   Optional, can be any length
-   Most functions don't need details
-   Use markdown headings (`@section Title:`) to organize longer content
-   Appears after usage and arguments in rendered docs, despite placement in roxygen
-   Good for deep dives into important function aspects

**Key Points**

-   Title and description appear together at top of docs
-   Details appear much later (after usage, arguments, return value)
-   Even adjacent in roxygen block, they're separated in output
-   Do write descriptions when function purpose seems "obvious" to you‚Äîit won't be to users
    -   Write descriptions after you have gone away from the function for a bit and can come back and write a meaningful description of what this function does when you are not hyper-aware of it because you just coded it

**2025-11-19:** Stopped at section 16.3

-   Moving quick and liking this chapter very much

**Arguments**

-   Document function parameters using `@param` followed by argument name and description.

-   **Priority: Provide succinct summary of allowed inputs and parameter action**

**Key practices:**

-   Describe what the parameter does and what inputs are allowed

-   Document default values in the description (even though shown in usage) since usage and description are often far apart in rendered docs

-   Accept the duplication trade-off‚Äîeasier for users, minimal extra maintenance

-   List fixed/enumerated options clearly

**Format options for fixed parameters:**

-   Simple options: inline sentence format (`"left"`, `"right"`, or `"both"` (the default))
-   Complex options: bulleted list with explanations for each option

**Length guidance:**

-   Most arguments: 1-2 sentences

-   Use as much space as needed for clarity

-   Multi-paragraph descriptions acceptable when necessary

**2025-11-21:** Stopped at 16.3.1

-   Very small progress today because I am exhausted from playing Elden Ring for 7 hours last night

    -   Love the game, but it is very time-consuming and addictive

    -   Not necessarily a bad thing, but it does mean I can't really perform optimally at the moment

**Multiple Arguments & @inheritParams**

**Multiple arguments together:**

-   Use `@param x,y` (comma-separated, no spaces) when arguments are tightly coupled
    -   Completely useless and not worth mentioning at all

@inheritParams**:**

-   Inherits argument docs from another function: `@inheritParams source_function`
    -   Extremely useful because many of the visualisation functions in my package share the same arguments and have the same documentation
    -   Could ask Claude or chatGPT to re-factor my code base for scRNA-Seq visualisation functions to document arguments in one place and then use @inheritParams to copy that documentation to every other function
-   Only inherits args the function actually uses and aren't already documented locally
-   Mix inheritance with local overrides‚Äîdocument specialized args yourself, inherit the rest
-   Cross-package: `@inheritParams pkg::fun` works but creates version dependency (watch for spurious diffs)
    -   Not a big fan of this because documentation is not self-contained in this case and could change significantly depending on the package that the documentation is depending on
    -   That's why it's a good idea to keep my own documentation self-contained and only inherit parameters from functions in my own code base, whose documentation is completely under my control

**2025-11-25:** Stopped at section 16.4

-   Excellent section on @inheritParams that is immensely useful

**Return Value Documentation (@returns)**

Document the output "`shape`": type, dimensions, and structure.

**Core elements:**

-   Object type (vector, matrix, data frame, list)
-   Dimensions/length relative to inputs
-   For matrices: what determines rows/columns
-   For data frames: effects on rows, columns, groups, attributes

**Additional info:**

-   Important warnings or errors users might encounter
-   CRAN requires @returns for all exported functions

**Example:** `@returns A logical vector the same length as string.`

**2025-11-26:** Stopped at section 16.5

-   Very short section

**Examples (@examples)**

**Core Tension**

-   Balance readable/realistic examples for users vs. error-free execution in automated contexts (CRAN, GitHub Actions)
-   Executed in 4 contexts: interactive example(), local/CRAN R CMD check, pkgdown builds

**Content Guidelines**

-   Show basic operation first, then key features
    -   The example below is a very excellent demonstration of this that starts off by showing basic functionality followed by more in-depth arguments and options that are worth noting
    -   If more needs to be said in these examples to document important behaviors, vignettes are always an option
-   Stay focused, avoid edge cases (those belong in tests)
-   Use familiar datasets (mtcars) when possible
    -   Can't stress this enough because it really helps users observe how new functionality interacts with datasets they already understand and have experience with
-   Use sectioning comments with dashes (---) for visual breaks
-   Create helper functions/datasets if setup is complex
    -   Creating a package dataset is my go-to solution but documenting my package datasets is what I have not gotten to yet
        -   Could be better to use `SeuratData` datasets instead of my own, but I would have to include the dataset pre-processing in the examples (not the best option for clear examples)

Example from `str_detect()`:

``` r
#' @examples
#' # ------ basic functionality ------
#' fruit <- c("apple", "banana", "pear", "pineapple")
#' str_detect(fruit, "a")        # basic usage
#' str_detect(fruit, "^a")       # simple variations
#' str_detect(fruit, "a$")
#' 
#' # ------ advanced functionality ------
#' # Also vectorised over pattern  ‚Üê highlights key feature
#' str_detect("aecfg", letters)
```

**Key Principle**

-   Examples are documentation for humans, not tests, so the focus should be on clarity and usability
    -   This is the first thing people are going to look at when trying to use your function with their data, so make sure you are helping them implement as much as possible

**2025-11-28:** Stopped at section 16.5.2

-   Small amount of progress but consistency is king always

**Leave the World as You Found It & Handling Errors**

**Self-Contained Examples**

-   Reset options, delete temporary files, don't change working directory
-   Can't use `withr` or `on.exit()` - must clean up manually
-   Must run quickly (CRAN: under 10 minutes total)
-   Avoid network calls or flaky code that can fail unpredictably

**Handling Errors**

-   `try()`: Wraps code to show error without stopping execution (recommended for teaching)
-   `\dontrun{}`: Prevents code execution entirely (common for platform-specific or conditional code)
    -   This is the most important option here, and it's used heavily by my own package as well as Seurat and some other major packages
        -   Very good way of showing the code even though it does not show the output\\
            -   However, if output must be shown, I think a vignette is a more suitable location for that
-   **CRAN restriction:** Initial submissions need at least one runnable example per function (can't wrap everything in `\dontrun{}`)

**2025-12-02:** Stopped at section 16.5.4

-   Consistency is king

**Dependencies and Conditional Execution**

**Package dependencies:**

-   Examples can only use packages listed in `Imports` or `Suggests`
-   Must explicitly attach with `library()` or use `package::function()` syntax
-   Example code runs in user's environment, not package environment

**Conditional execution - old approach (NOT recommended):**

-   Previously suggested wrapping in `if (requireNamespace("pkg", quietly = TRUE))` blocks
-   No longer recommended because: (1) suggested packages should be installed during R CMD check, (2) hiding code in `{ }` blocks prevents seeing intermediate results in rendered docs

**Conditional execution - modern approach:**

-   Use `@examplesIf some_condition()` instead of `@examples` with if-blocks
-   Condition can be `interactive()` or custom predicate function from your package
-   Advantages: cleaner docs, full rendering in pkgdown, runs when appropriate, avoids CRAN's `\dontrun{}` prohibition

**Alternative documentation approaches:**

-   ```` ```R ```` blocks show code without running (risk of syntax errors/outdated code)
-   ```` ```{r} ```` blocks run code and include output (but runs every time you document, slowing workflow)

**2025-12-03:** Stopped at section 16.6

-   Short and sweet

**Re-using Documentation & Package Help Topics**

**Multiple Functions in One Topic**

-   Use `@rdname topic_name` to merge closely related functions into single page
-   First function has full docs; others reference with `@rdname`
-   Best for functions with similar arguments, returns, and examples

**Inheriting Documentation**

-   `@inheritParams source_function`: inherit parameter documentation
    -   Very effective method, especially when more than one function uses the same parameters as with visualisation functions
-   `@inherit source_function`: inherit all supported components
-   `@inheritSection source_function Section title`: inherit specific section
-   `@inheritDotParams`: auto-generate `...` parameter docs when passing to another function
    -   This is immensely useful and will help me add documentation for my `BadranSeq::DimPlot()` functions based on `SCPubr::DimPlot()` further options for controlling titles, sizes, etc.

**Child Documents**

-   Reuse `.Rmd`/`.md` files across docs, README, and vignettes
-   Syntax: ```` #' ```{r child = "man/rmd/filename.Rmd"} ````
-   Place reusable content in `man/rmd/` directory

**Package-Level Help Topic**

-   Call `usethis::use_package_doc()` to create `R/{pkgname}-package.R`
-   Document `"_PACKAGE"` sentinel for package help (accessible via `?pkgname`)
-   Natural location for `@importFrom` directives via `usethis::use_import_from()`

**2025-12-04:** End of chapter 16

-   Some advice is relevant but a lot is not

    -   Simple enough

# Chapter 17: Vignettes

**Vignettes Overview**

**Purpose & Function**

-   Vignettes are long-form package guides focused on solving target problems
-   Show workflow from start to finish, demonstrating how multiple functions work together
-   Better than function docs for discovering package capabilities without knowing specific function names
-   Provide more control over code-prose integration than help topics

**Discovery & Access**

-   View all installed vignettes: `browseVignettes()`
-   View package-specific: `browseVignettes("tidyr")`
-   Read specific vignette: `vignette("rectangle", package = "tidyr")`
-   Prefer pkgdown websites over CRAN for better navigation (uses "article" terminology for user-facing docs)
-   Technical distinction: vignettes ship with package, articles exist only on website

**Initial Setup**

-   Create first vignette: `usethis::use_vignette("my-vignette")`
-   Creates `vignettes/` directory
-   Adds `knitr` to `VignetteBuilder` field in `DESCRIPTION`
-   Adds `knitr` and `rmarkdown` to `Suggests`
-   Drafts `vignettes/my-vignette.Rmd`
-   Configures `.gitignore` for preview artifacts

**Development Workflow**

-   Add content to vignette using standard R Markdown
-   Use `devtools::load_all()` for interactive development
-   **Critical issue:** vignettes render against installed package version by default (via `library(yourpackage)`)
-   Must ensure you're building against current source, not stale installed version

**Rendering Options**

-   Install then render: `devtools::install()` or Ctrl/Cmd+Shift+B, then Ctrl/Cmd+Shift+K
-   Install with vignettes: `install(build_vignettes = TRUE)` then `browseVignettes()`
-   Build against dev version: `devtools::build_rmd("vignettes/my-vignette.Rmd")`

**Best Practices**

-   Treat `inst/doc/` as auto-generated (like `man/` and NAMESPACE) - don't edit manually
-   Avoid complicated base R vignette maneuvers
-   Regular `devtools::check()` keeps vignettes in working order
-   Check catches undeclared package dependencies in vignettes

**2025-12-11:** Stopped at 17.2

-   Brief but very useful

    -   This chapter integrates heavily with Chapter 19 on building a site for my package using `pkgdown`

    -   That is the point at which I will create my own scRNA-Seq visualisation package with its attached documentation, vignettes, and sites

**Vignette Metadata**

**Creation**

-   Use `usethis::use_vignette("name")` to generate vignette template with correct metadata

**YAML Frontmatter**

-   `title`: Display title (must manually match VignetteIndexEntry)
-   `output: rmarkdown::html_vignette`: Optimized output format
-   `vignette` block: Three LaTeX-style entries
    -   `%\VignetteIndexEntry{Title}`: Index name (match title exactly)
    -   `%\VignetteEngine{knitr::rmarkdown}`: Don't change
    -   `%\VignetteEncoding{UTF-8}`: Don't change

**Standard Setup**

-   First chunk: knitr display options
-   Second chunk: `library(yourpackage)` (never use `load_all()` in vignette source)
-   Of course, this is all going to be different if we are dealing with quarto documents instead of rmd ones, but I will gain a more practical understanding of these mechanics later when I am implementing this in my own package

**Avoid**

-   `author` field (unless different from package authors)
-   `date` field (maintenance burden, unclear meaning)

**2025-12-12:** Stopped at section 17.3

-   Short and sweet

**Vignette Writing Advice**

**Core Principles**

-   Writing reveals code problems and usability issues before release
-   Adopt beginner's mind - teaching exposes what you've internalized
-   Kathy Sierra's work (Creating Passionate Users, Serious Pony) recommended for timeless teaching/tool-building advice

**Technical Details**

-   Watch file size with graphics - may trigger CRAN NOTEs
-   No official cross-linking between vignettes/help - use pkgdown for automatic hyperlinks
-   Backtick syntax: `` `function()` `` for functions, `` `vignette("topic")` `` for vignettes

**File References**

-   Generated figures: auto-embedded as data URIs
-   User-facing files: `inst/extdata/` with `system.file()`
-   Vignette-only files: `vignettes/` with relative paths
-   Graphics: `vignettes/` with `knitr::include_graphics()`

**Structure**

-   Simple packages: single `packagename.Rmd` vignette (gets pkgdown "Get started" link)
-   Complex packages: multiple self-contained vignettes as cohesive chapters

**Publication**

-   JSS/R Journal for detailed algorithms
-   JOSS for fast, lightweight citation papers

**2026-01-13:** Took a long break due to everything happening in life (grade upgrade at work and termination of my engagement), and now I am back and stopped at section 17.4

-   **Vignette code must be written differently** from analysis scripts (more like **examples/tests**): reproducible, robust, and CRAN-safe.

-   **All packages used in vignettes must be formal dependencies** in `DESCRIPTION` (**Imports** or **Suggests**).

    -   Policy: assume **Suggests packages are installed** when vignettes are built (except rare hard-to-install cases).

-   Vignette code may fail on CRAN/CI due to **credentials**, **slow runtime**, **API instability**, etc. ‚Üí you must guard it.

-   Main control is knitr chunk option **`eval`**:

    -   `eval = TRUE/FALSE`

    -   Can be **conditional expressions** like:

        -   `eval = requireNamespace("pkg")`
        -   `eval = Sys.getenv("TOKEN") != ""`
        -   `eval = file.exists("credentials")`

-   Often you either run **almost everything** or **almost nothing**:

    -   Use early hidden setup chunk: `knitr::opts_chunk$set(eval = FALSE)` (or `eval = can_run`)
    -   Override individual chunks with `eval = TRUE` if needed.

-   Good practice: if code can‚Äôt run, print an **explanatory message** in a chunk with `eval = !can_run`.

-   Helpful chunk options:

    -   `include = FALSE` (run but don‚Äôt show)
    -   `echo = FALSE` (hide code)
    -   `error = TRUE` (allow errors without failing the whole vignette/check).

-   If you don‚Äôt want anything executed on CRAN: write a **pkgdown article** (website-only), not a vignette.

-   Workflow detail: `.Rmd` source lives in `vignettes/` and gets rendered at **`R CMD build`** into `inst/doc/`.

-   **`R CMD check` treats vignettes like tests**: it tangles and runs code, then rebuilds the vignette ‚Üí code may execute **up to 2 times**, so failing chunks must be suppressed via `eval`.

**2026-01-14:** Chapter 17 is complete

-   Lots of waffling in these guides so I am starting to get into the habit of ignoring lines that makes no sense or ramble on when I read (a skill I am now developing with my style of reading papers)

# Chapter 18: Other Markdown Files

**Package-Level Documentation Files**

Two critical files for package communication:

**README.md**

**Purpose**: Answer three key questions for potential users

-   Why should I use this package?
-   How do I use it?
-   How do I get it?

**Recommended structure**:

-   High-level purpose paragraph describing what problem the package solves
-   Simple example showing basic usage
-   Installation instructions (copy-pasteable R code)
-   Secondary items:
    -   Overview of main components (link to vignettes for complex packages)
    -   Description of how package fits into the broader domain ecosystem
-   **Context**: Featured on CRAN landing page, pkgdown site, and crucial for GitHub discoverability

**NEWS.md**

**Purpose**: Document package evolution over time

-   Version releases
-   Major updates and changes
-   Breaking changes and deprecations

**General Notes**

-   Both files strongly recommended even for limited-audience packages

-   Use Markdown format for consistency with vignettes and help topics

**2026-01-19:** Stopped at section 18.1.1

-   Cool and short chapter about `README.md` and `NEWS.md`, both of which are immensely useful in general

**README.Rmd and README.md**

**Why README.Rmd over plain README.md:**

-   Allows executable R code chunks with real examples
-   Renders to GitHub Flavored Markdown
-   Images saved to `man/figures/README-` are included in built package (works on CRAN)
    -   This is set in the `knitr` options
    -   `man` is also the home for function documentation, and this documentation is generated automatically by `roxygen2`

**Where README.md displays:**

-   GitHub repository home page
-   CRAN package page (as hyperlinked "README" under Materials)
    -   There is also NEWS there and it's really useful
-   pkgdown site home page

**Setup:** `usethis::use_readme_rmd()`

-   Creates template README.Rmd with recommended knitr options
-   Adds README.Rmd to `.Rbuildignore` (only README.md goes in package bundle)
    -   This is one of the nice things about `usethis` functions, and that's their handling of `.gitignore` and `.Rbuildignore`
-   Includes placeholder for badges (CRAN version, test coverage, CI status)
    -   Cool but I do not understand those fully yet

**Keeping README.md current:**

-   Render with `devtools::build_readme()` ‚Äî guarantees rendering against current source code
    -   This essentially updates the `readme.md` if the `readme.rmd` changes, which is ideal
-   Essential before release

**Automatic safeguards:**

-   Pre-commit Git hook added by `use_readme_rmd()` ‚Äî blocks commits if README.Rmd is newer than README.md (override with `git commit --no-verify`)
    -   Very cool and something I did not know was possible
        -   Need to look into pre-commit hooks a bit more
-   Hook not stored in repo; re-run `use_readme_rmd()` on fresh clones to restore
    -   Also good to remember that the hook is added to this repo if it's a github repo but not on clones of the repo
-   Release checklist from `usethis::use_release_issue()` includes reminder to rebuild using `devtools::build_readme()`

**2026-01-21:** Stopped at section 18.2

-   Small but cool progress today

**NEWS File**

-   Create `NEWS.md` to document user-facing changes in each release
-   Use `usethis::use_news_md()` to initialize the file

**Visibility & Access**

-   Appears on GitHub, CRAN landing page, and pkgdown site
-   Targets existing users (unlike README which targets new users)

**Structure**

-   Top-level heading per version: `# packagename 1.0.0`
-   Most recent version at top; development version: `# packagename (development version)`
-   Organize changes as bulleted lists
-   Use subheadings for many changes: `## Major changes`, `## Bug fixes`

**Content Guidelines**

-   Link issues/PRs: `(#10)` for issues, `(#101, @hadley)` for PRs with authors
-   Record user-visible changes, not developer details
-   Polish before release (included in `usethis::use_release_issue()` checklist)

**Best Practices**

-   Note changes when you make them, especially for external contributions
-   Compare versions before release to catch missing items
-   Organize and refine text near release time

**2026-01-29:** End of chapter 18

# Chapter 19: Website

-   pkgdown automatically builds a package website from existing documentation (help topics, vignettes, README, NEWS)

-   `usethis::use_pkgdown()` ‚Äî run once for initial setup

    -   creates `_pkgdown.yml` config

        -   configuration file for `pkgdown` behaviour

    -   updates `.Rbuildignore` and `.gitignore`

-   `pkgdown::build_site()` ‚Äî run repeatedly to re-render the site locally into `docs/`

-   Works immediately on any valid R package with no configuration needed

-   `docs/` is gitignored by default because the recommended workflow is to build and deploy via GitHub Actions/Pages

    -   `docs/` is where the package will live

    -   documentation lives in `man/` in case I am wondering later

-   Local `docs/` folder is just for preview; open `docs/index.html` to browse

-   `pkgdown`'s own site ([pkgdown.r-lib.org](https://pkgdown.r-lib.org)) covers advanced configuration

**2026-02-03:** Stopped at section 19.2

-   Cool chapter, small progress
